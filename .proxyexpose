
Perfect üëç let‚Äôs make this generic with Helm so you don‚Äôt have to hardcode every service proxy.

We‚Äôll build a small Helm chart called swagger-proxy.

‚∏ª

üìÇ Directory Structure

swagger-proxy/
  Chart.yaml
  values.yaml
  templates/
    configmap.yaml
    deployment.yaml
    service.yaml
    ingress.yaml


‚∏ª

üìù Chart.yaml

apiVersion: v2
name: swagger-proxy
description: Proxy Swagger UI + API services from Cluster A into Cluster B
version: 0.1.0
appVersion: "1.0"


‚∏ª

üìù values.yaml

Here you configure all the endpoints to proxy:

replicaCount: 1

image:
  repository: nginx
  tag: alpine

ingress:
  enabled: true
  host: swagger-clusterB.com

# Proxy rules
# Each entry maps a path on Cluster B ‚Üí a target in Cluster A
proxies:
  - path: /
    target: https://swagger-clusterA.com/
    hostHeader: swagger-clusterA.com

  - path: /service1/
    target: https://api-service1.clusterA.com/
    hostHeader: api-service1.clusterA.com

  - path: /service2/
    target: https://api-service2.clusterA.com/
    hostHeader: api-service2.clusterA.com


‚∏ª

üìù templates/configmap.yaml

apiVersion: v1
kind: ConfigMap
metadata:
  name: swagger-proxy-config
data:
  nginx.conf: |
    events {}
    http {
      server {
        listen 8080;

        {{- range .Values.proxies }}
        location {{ .path }} {
          proxy_pass {{ .target }};
          proxy_set_header Host {{ .hostHeader }};
        }
        {{- end }}
      }
    }


‚∏ª

üìù templates/deployment.yaml

apiVersion: apps/v1
kind: Deployment
metadata:
  name: swagger-proxy
spec:
  replicas: {{ .Values.replicaCount }}
  selector:
    matchLabels:
      app: swagger-proxy
  template:
    metadata:
      labels:
        app: swagger-proxy
    spec:
      containers:
      - name: nginx
        image: "{{ .Values.image.repository }}:{{ .Values.image.tag }}"
        ports:
        - containerPort: 8080
        volumeMounts:
        - name: config
          mountPath: /etc/nginx/nginx.conf
          subPath: nginx.conf
      volumes:
      - name: config
        configMap:
          name: swagger-proxy-config


‚∏ª

üìù templates/service.yaml

apiVersion: v1
kind: Service
metadata:
  name: swagger-proxy
spec:
  selector:
    app: swagger-proxy
  ports:
    - port: 8080
      targetPort: 8080
  type: ClusterIP


‚∏ª

üìù templates/ingress.yaml

{{- if .Values.ingress.enabled }}
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: swagger-proxy-ingress
spec:
  rules:
    - host: {{ .Values.ingress.host }}
      http:
        paths:
        {{- range .Values.proxies }}
          - path: {{ .path }}
            pathType: Prefix
            backend:
              service:
                name: swagger-proxy
                port:
                  number: 8080
        {{- end }}
{{- end }}


‚∏ª

üöÄ Deploy

helm install swagger-proxy ./swagger-proxy


‚∏ª

üîπ How it Works
	‚Ä¢	Users go to https://swagger-clusterB.com
	‚Ä¢	Requests to / ‚Üí proxied to https://swagger-clusterA.com
	‚Ä¢	Requests to /service1/ ‚Üí proxied to https://api-service1.clusterA.com
	‚Ä¢	Requests to /service2/ ‚Üí proxied to https://api-service2.clusterA.com
	‚Ä¢	You can add/remove services just by editing values.yaml.

‚∏ª

Do you also want me to show how to make the proxy auto-rewrite the Swagger UI URLs (so that instead of api-service1.clusterA.com showing up in the docs, it automatically rewrites to swagger-clusterB.com/service1/)? That way users never even see the Cluster A domains.


======
Perfect üëç you want a Helmized proxy deployment in Cluster B that can forward to a list of Swagger services in Cluster A.

Here‚Äôs a clean Helm chart structure + YAML configs that you can adapt.

‚∏ª

üîπ Directory Structure

swagger-proxy/
‚îú‚îÄ‚îÄ Chart.yaml
‚îú‚îÄ‚îÄ values.yaml
‚îú‚îÄ‚îÄ templates/
‚îÇ   ‚îú‚îÄ‚îÄ configmap.yaml
‚îÇ   ‚îú‚îÄ‚îÄ deployment.yaml
‚îÇ   ‚îú‚îÄ‚îÄ service.yaml
‚îÇ   ‚îî‚îÄ‚îÄ ingress.yaml


‚∏ª

üîπ Chart.yaml

apiVersion: v2
name: swagger-proxy
description: Reverse proxy for Swagger services in Cluster A
version: 0.1.0
appVersion: "1.0"


‚∏ª

üîπ values.yaml

Here you define the list of services in Cluster A you want to proxy.

replicaCount: 1

image:
  repository: nginx
  tag: alpine
  pullPolicy: IfNotPresent

service:
  type: ClusterIP
  port: 8080

ingress:
  enabled: true
  className: ""
  hosts:
    - host: swagger-proxy.clusterB.com
      paths:
        - path: /
          pathType: Prefix
          backendPort: 8080
  tls: []   # e.g., configure if you have certs

# List of Swagger services in Cluster A
services:
  - name: service1
    url: https://service1.clusterA.com/swagger/
  - name: service2
    url: https://service2.clusterA.com/swagger/
  - name: service3
    url: https://service3.clusterA.com/swagger/


‚∏ª

üîπ templates/configmap.yaml

apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ include "swagger-proxy.fullname" . }}-config
data:
  nginx.conf: |
    events {}
    http {
      server {
        listen {{ .Values.service.port }};
        {{- range .Values.services }}
        location /{{ .name }}/ {
          proxy_pass {{ .url }};
          proxy_set_header Host {{ regexReplaceAll "https?://" .url "" }};
        }
        {{- end }}
      }
    }


‚∏ª

üîπ templates/deployment.yaml

apiVersion: apps/v1
kind: Deployment
metadata:
  name: {{ include "swagger-proxy.fullname" . }}
spec:
  replicas: {{ .Values.replicaCount }}
  selector:
    matchLabels:
      app: {{ include "swagger-proxy.name" . }}
  template:
    metadata:
      labels:
        app: {{ include "swagger-proxy.name" . }}
    spec:
      containers:
      - name: nginx
        image: "{{ .Values.image.repository }}:{{ .Values.image.tag }}"
        imagePullPolicy: {{ .Values.image.pullPolicy }}
        ports:
        - containerPort: {{ .Values.service.port }}
        volumeMounts:
        - name: config
          mountPath: /etc/nginx/nginx.conf
          subPath: nginx.conf
      volumes:
      - name: config
        configMap:
          name: {{ include "swagger-proxy.fullname" . }}-config


‚∏ª

üîπ templates/service.yaml

apiVersion: v1
kind: Service
metadata:
  name: {{ include "swagger-proxy.fullname" . }}
spec:
  type: {{ .Values.service.type }}
  selector:
    app: {{ include "swagger-proxy.name" . }}
  ports:
  - port: {{ .Values.service.port }}
    targetPort: {{ .Values.service.port }}


‚∏ª

üîπ templates/ingress.yaml

{{- if .Values.ingress.enabled }}
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: {{ include "swagger-proxy.fullname" . }}
spec:
  rules:
  {{- range .Values.ingress.hosts }}
  - host: {{ .host }}
    http:
      paths:
      {{- range .paths }}
      - path: {{ .path }}
        pathType: {{ .pathType }}
        backend:
          service:
            name: {{ include "swagger-proxy.fullname" $ }}
            port:
              number: {{ .backendPort }}
      {{- end }}
  {{- end }}
{{- end }}


‚∏ª

üîπ How It Works
	1.	Add your Cluster A Swagger services in values.yaml under .services.

services:
  - name: service1
    url: https://service1.clusterA.com/swagger/
  - name: service2
    url: https://service2.clusterA.com/swagger/


	2.	Deploy Helm chart in Cluster B:

helm install swagger-proxy ./swagger-proxy


	3.	Access endpoints from Cluster B users:

https://swagger-proxy.clusterB.com/service1/
https://swagger-proxy.clusterB.com/service2/



‚∏ª

‚úÖ This setup needs no changes in Cluster A (since it‚Äôs already exposed via Ingress).
‚úÖ Users who only have access to Cluster B can now consume Cluster A Swagger via the proxy.

‚∏ª

Do you want me to also include basic auth / IP restriction in this proxy Helm chart so only selected users can use it?

Perfect, now it‚Äôs very clear üëç
	‚Ä¢	Cluster A Swagger services are already exposed via Ingress (https://service1.clusterA.com/...).
	‚Ä¢	Some users cannot access them directly (due to zone / firewall restrictions).
	‚Ä¢	But those same users can access Cluster B.
	‚Ä¢	‚úÖ So we just need to give them a proxy endpoint inside Cluster B, which forwards their requests to Cluster A.

‚∏ª

üîπ Solution: Proxy in Cluster B for Cluster A‚Äôs Ingress

Step 1. Nginx Config

We‚Äôll create an Nginx reverse proxy in Cluster B.
Example for 2 services (service1 and service2):

events {}
http {
  server {
    listen 8080;

    location /service1/ {
      proxy_pass https://service1.clusterA.com/;
    }

    location /service2/ {
      proxy_pass https://service2.clusterA.com/;
    }
  }
}


‚∏ª

Step 2. Kubernetes YAML (in Cluster B)

apiVersion: v1
kind: ConfigMap
metadata:
  name: swagger-proxy-config
data:
  nginx.conf: |
    events {}
    http {
      server {
        listen 8080;

        location /service1/ {
          proxy_pass https://service1.clusterA.com/;
          proxy_set_header Host service1.clusterA.com;
        }

        location /service2/ {
          proxy_pass https://service2.clusterA.com/;
          proxy_set_header Host service2.clusterA.com;
        }
      }
    }
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: swagger-proxy
spec:
  replicas: 1
  selector:
    matchLabels:
      app: swagger-proxy
  template:
    metadata:
      labels:
        app: swagger-proxy
    spec:
      containers:
      - name: nginx
        image: nginx:alpine
        ports:
        - containerPort: 8080
        volumeMounts:
        - name: config
          mountPath: /etc/nginx/nginx.conf
          subPath: nginx.conf
      volumes:
      - name: config
        configMap:
          name: swagger-proxy-config
---
apiVersion: v1
kind: Service
metadata:
  name: swagger-proxy
spec:
  selector:
    app: swagger-proxy
  ports:
  - port: 8080
    targetPort: 8080
  type: ClusterIP


‚∏ª

Step 3. Optional: Expose in Cluster B

If users need to access it from outside Cluster B, expose it with an Ingress or a LoadBalancer Service:

apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: swagger-proxy-ingress
spec:
  rules:
  - host: swagger-proxy.clusterB.com
    http:
      paths:
      - path: /service1/
        pathType: Prefix
        backend:
          service:
            name: swagger-proxy
            port:
              number: 8080
      - path: /service2/
        pathType: Prefix
        backend:
          service:
            name: swagger-proxy
            port:
              number: 8080


‚∏ª

üîπ Final Access Flow
	‚Ä¢	User cannot access https://service1.clusterA.com directly.
	‚Ä¢	User goes to:

https://swagger-proxy.clusterB.com/service1/


	‚Ä¢	Request goes ‚Üí Cluster B Nginx ‚Üí forwards to https://service1.clusterA.com/ in Cluster A.
	‚Ä¢	Response comes back via the proxy.

‚∏ª

‚úÖ No changes needed in Cluster A (since it‚Äôs already exposed by Ingress).
‚úÖ Only deploy a proxy Deployment + Service + Ingress in Cluster B.

‚∏ª

Do you want me to extend this YAML so you can proxy an arbitrary list of services (like 10+ Swagger endpoints) with just one config?