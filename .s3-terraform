PowerShell sees the *```hcl ... ```* part and gets confused because the string block ends early, causing the *“At line 96: unexpected token”* type of error.

---

## ✅ FIXED VERSION

Below is the corrected version of that section (replace in your script from line ~96 onward):

```powershell
# --- modules/s3-backend/README.md ---
$readmeContent = @"
# S3 Backend Module

Creates:
- S3 bucket for Terraform state
- DynamoDB for state locking

## Usage Example

\`\`\`hcl
module "s3_backend" {
  source         = "../../modules/s3-backend"
  aws_region     = "us-east-1"
  s3_bucket_name = "mycompany-tfstate-dev"
  tags = {
    Environment = "dev"
  }
}
\`\`\`
"@

Set-Content "$modulePath/README.md" $readmeContent



Perfect 👍 — you want:
	•	A single common Terraform configuration (main files shared across environments).
	•	Environment-specific variables (*.tfvars) that drive each deployment (e.g., dev, qa, prod).
	•	Automated folder and file creation via PowerShell.

So instead of separate main.tf per environment, we’ll have this structure:

terraform-infra/
├── main.tf
├── variables.tf
├── outputs.tf
├── backend.tf
├── modules/
│   └── s3-backend/
│       ├── main.tf
│       ├── variables.tf
│       ├── outputs.tf
│       └── README.md
├── environments/
│   ├── dev.tfvars
│   ├── qa.tfvars
│   └── prod.tfvars
├── .github/
│   └── workflows/
│       └── terraform.yml
└── setup-terraform-structure.ps1

Now here’s a PowerShell script that builds this shared main + env tfvars structure automatically.

⸻

🧰 PowerShell Script — setup-terraform-structure.ps1

# =====================================================
# Terraform Infra Bootstrap Script (Shared Main + Env tfvars)
# =====================================================

$root = "terraform-infra"
$modulePath = "$root/modules/s3-backend"
$envPath = "$root/environments"
$workflowPath = "$root/.github/workflows"

# --- Create Folder Structure ---
New-Item -Path $modulePath -ItemType Directory -Force | Out-Null
New-Item -Path $envPath -ItemType Directory -Force | Out-Null
New-Item -Path $workflowPath -ItemType Directory -Force | Out-Null

# =====================================================
# MODULE FILES
# =====================================================

# --- modules/s3-backend/main.tf ---
@'
resource "aws_s3_bucket" "tf_state" {
  bucket = var.s3_bucket_name
  acl    = "private"

  versioning {
    enabled = true
  }

  server_side_encryption_configuration {
    rule {
      apply_server_side_encryption_by_default {
        sse_algorithm = "AES256"
      }
    }
  }

  tags = merge(
    {
      ManagedBy = "Terraform"
    },
    var.tags
  )
}

resource "aws_dynamodb_table" "tf_lock" {
  name         = "${var.s3_bucket_name}-lock"
  billing_mode = "PAY_PER_REQUEST"
  hash_key     = "LockID"

  attribute {
    name = "LockID"
    type = "S"
  }

  tags = merge(
    {
      ManagedBy = "Terraform"
    },
    var.tags
  )
}
'@ | Set-Content "$modulePath/main.tf"

# --- modules/s3-backend/variables.tf ---
@'
variable "aws_region" {
  description = "AWS region for S3 bucket and DynamoDB"
  type        = string
}

variable "s3_bucket_name" {
  description = "S3 bucket name for storing Terraform state"
  type        = string
}

variable "tags" {
  description = "Tags for resources"
  type        = map(string)
  default     = {}
}
'@ | Set-Content "$modulePath/variables.tf"

# --- modules/s3-backend/outputs.tf ---
@'
output "s3_bucket_name" {
  value = aws_s3_bucket.tf_state.bucket
}

output "dynamodb_table_name" {
  value = aws_dynamodb_table.tf_lock.name
}
'@ | Set-Content "$modulePath/outputs.tf"

# --- modules/s3-backend/README.md ---
@'
# S3 Backend Module

Creates:
- S3 bucket for Terraform state
- DynamoDB for state locking

Usage:
```hcl
module "s3_backend" {
  source         = "../../modules/s3-backend"
  aws_region     = var.aws_region
  s3_bucket_name = var.s3_bucket_name
  tags = {
    Environment = var.environment
  }
}

’@ | Set-Content “$modulePath/README.md”

=====================================================

ROOT (COMMON) TERRAFORM FILES

=====================================================

— main.tf —

@’
provider “aws” {
region = var.aws_region
}

module “s3_backend” {
source         = “./modules/s3-backend”
aws_region     = var.aws_region
s3_bucket_name = var.s3_bucket_name
tags = {
Environment = var.environment
Project     = “terraform-infra”
}
}

output “bucket_name” {
value = module.s3_backend.s3_bucket_name
}

output “dynamodb_table” {
value = module.s3_backend.dynamodb_table_name
}
’@ | Set-Content “$root/main.tf”

— variables.tf —

@’
variable “aws_region” {
description = “AWS region”
type        = string
}

variable “environment” {
description = “Deployment environment”
type        = string
}

variable “s3_bucket_name” {
description = “Terraform state bucket name”
type        = string
}
’@ | Set-Content “$root/variables.tf”

— outputs.tf —

@’
output “terraform_backend” {
value = {
bucket         = module.s3_backend.s3_bucket_name
dynamodb_table = module.s3_backend.dynamodb_table_name
region         = var.aws_region
}
}
’@ | Set-Content “$root/outputs.tf”

— backend.tf —

@’
terraform {
backend “s3” {}
}
’@ | Set-Content “$root/backend.tf”

=====================================================

ENVIRONMENT-SPECIFIC TFVARS

=====================================================

@’
aws_region      = “us-east-1”
environment     = “dev”
s3_bucket_name  = “mycompany-tfstate-dev”
’@ | Set-Content “$envPath/dev.tfvars”

@’
aws_region      = “us-east-1”
environment     = “qa”
s3_bucket_name  = “mycompany-tfstate-qa”
’@ | Set-Content “$envPath/qa.tfvars”

@’
aws_region      = “us-east-1”
environment     = “prod”
s3_bucket_name  = “mycompany-tfstate-prod”
’@ | Set-Content “$envPath/prod.tfvars”

=====================================================

GITHUB WORKFLOW

=====================================================

@’
name: Terraform Infra Setup

on:
push:
branches:
- main
paths:
- “**/.tf”
- “environments/.tfvars”

jobs:
terraform:
runs-on: ubuntu-latest
env:
AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
AWS_DEFAULT_REGION: us-east-1

steps:
  - name: Checkout Code
    uses: actions/checkout@v4

  - name: Setup Terraform
    uses: hashicorp/setup-terraform@v3
    with:
      terraform_version: 1.9.8

  - name: Init
    run: terraform init

  - name: Validate
    run: terraform validate

  - name: Plan (Dev)
    run: terraform plan -var-file=environments/dev.tfvars -out=tfplan

  - name: Apply (Dev)
    run: terraform apply -auto-approve tfplan

’@ | Set-Content “$workflowPath/terraform.yml”

Write-Host “✅ Terraform shared structure created successfully at: $root”

---

## 🧾 Run the Script

```powershell
# Run in PowerShell from your working directory
.\setup-terraform-structure.ps1


⸻

✅ Resulting Structure

terraform-infra/
├── main.tf                # Common logic
├── variables.tf           # Shared variable definitions
├── outputs.tf             # Shared outputs
├── backend.tf             # S3 backend placeholder
├── modules/
│   └── s3-backend/
│       ├── main.tf
│       ├── variables.tf
│       ├── outputs.tf
│       └── README.md
├── environments/
│   ├── dev.tfvars
│   ├── qa.tfvars
│   └── prod.tfvars
└── .github/
    └── workflows/
        └── terraform.yml


⸻

💡 Usage Example

Initialize & apply for a specific environment:

# Dev
terraform init
terraform plan -var-file=environments/dev.tfvars
terraform apply -var-file=environments/dev.tfvars -auto-approve

# QA
terraform plan -var-file=environments/qa.tfvars
terraform apply -var-file=environments/qa.tfvars -auto-approve


⸻

Would you like me to extend this script so that it also auto-runs terraform init + plan after creating the files (for immediate test setup)?