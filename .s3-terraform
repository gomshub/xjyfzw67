PowerShell sees the *```hcl ... ```* part and gets confused because the string block ends early, causing the *â€œAt line 96: unexpected tokenâ€* type of error.

---

## âœ… FIXED VERSION

Below is the corrected version of that section (replace in your script from line ~96 onward):

```powershell
# --- modules/s3-backend/README.md ---
$readmeContent = @"
# S3 Backend Module

Creates:
- S3 bucket for Terraform state
- DynamoDB for state locking

## Usage Example

\`\`\`hcl
module "s3_backend" {
  source         = "../../modules/s3-backend"
  aws_region     = "us-east-1"
  s3_bucket_name = "mycompany-tfstate-dev"
  tags = {
    Environment = "dev"
  }
}
\`\`\`
"@

Set-Content "$modulePath/README.md" $readmeContent



Perfect ğŸ‘ â€” you want:
	â€¢	A single common Terraform configuration (main files shared across environments).
	â€¢	Environment-specific variables (*.tfvars) that drive each deployment (e.g., dev, qa, prod).
	â€¢	Automated folder and file creation via PowerShell.

So instead of separate main.tf per environment, weâ€™ll have this structure:

terraform-infra/
â”œâ”€â”€ main.tf
â”œâ”€â”€ variables.tf
â”œâ”€â”€ outputs.tf
â”œâ”€â”€ backend.tf
â”œâ”€â”€ modules/
â”‚   â””â”€â”€ s3-backend/
â”‚       â”œâ”€â”€ main.tf
â”‚       â”œâ”€â”€ variables.tf
â”‚       â”œâ”€â”€ outputs.tf
â”‚       â””â”€â”€ README.md
â”œâ”€â”€ environments/
â”‚   â”œâ”€â”€ dev.tfvars
â”‚   â”œâ”€â”€ qa.tfvars
â”‚   â””â”€â”€ prod.tfvars
â”œâ”€â”€ .github/
â”‚   â””â”€â”€ workflows/
â”‚       â””â”€â”€ terraform.yml
â””â”€â”€ setup-terraform-structure.ps1

Now hereâ€™s a PowerShell script that builds this shared main + env tfvars structure automatically.

â¸»

ğŸ§° PowerShell Script â€” setup-terraform-structure.ps1

# =====================================================
# Terraform Infra Bootstrap Script (Shared Main + Env tfvars)
# =====================================================

$root = "terraform-infra"
$modulePath = "$root/modules/s3-backend"
$envPath = "$root/environments"
$workflowPath = "$root/.github/workflows"

# --- Create Folder Structure ---
New-Item -Path $modulePath -ItemType Directory -Force | Out-Null
New-Item -Path $envPath -ItemType Directory -Force | Out-Null
New-Item -Path $workflowPath -ItemType Directory -Force | Out-Null

# =====================================================
# MODULE FILES
# =====================================================

# --- modules/s3-backend/main.tf ---
@'
resource "aws_s3_bucket" "tf_state" {
  bucket = var.s3_bucket_name
  acl    = "private"

  versioning {
    enabled = true
  }

  server_side_encryption_configuration {
    rule {
      apply_server_side_encryption_by_default {
        sse_algorithm = "AES256"
      }
    }
  }

  tags = merge(
    {
      ManagedBy = "Terraform"
    },
    var.tags
  )
}

resource "aws_dynamodb_table" "tf_lock" {
  name         = "${var.s3_bucket_name}-lock"
  billing_mode = "PAY_PER_REQUEST"
  hash_key     = "LockID"

  attribute {
    name = "LockID"
    type = "S"
  }

  tags = merge(
    {
      ManagedBy = "Terraform"
    },
    var.tags
  )
}
'@ | Set-Content "$modulePath/main.tf"

# --- modules/s3-backend/variables.tf ---
@'
variable "aws_region" {
  description = "AWS region for S3 bucket and DynamoDB"
  type        = string
}

variable "s3_bucket_name" {
  description = "S3 bucket name for storing Terraform state"
  type        = string
}

variable "tags" {
  description = "Tags for resources"
  type        = map(string)
  default     = {}
}
'@ | Set-Content "$modulePath/variables.tf"

# --- modules/s3-backend/outputs.tf ---
@'
output "s3_bucket_name" {
  value = aws_s3_bucket.tf_state.bucket
}

output "dynamodb_table_name" {
  value = aws_dynamodb_table.tf_lock.name
}
'@ | Set-Content "$modulePath/outputs.tf"

# --- modules/s3-backend/README.md ---
@'
# S3 Backend Module

Creates:
- S3 bucket for Terraform state
- DynamoDB for state locking

Usage:
```hcl
module "s3_backend" {
  source         = "../../modules/s3-backend"
  aws_region     = var.aws_region
  s3_bucket_name = var.s3_bucket_name
  tags = {
    Environment = var.environment
  }
}

â€™@ | Set-Content â€œ$modulePath/README.mdâ€

=====================================================

ROOT (COMMON) TERRAFORM FILES

=====================================================

â€” main.tf â€”

@â€™
provider â€œawsâ€ {
region = var.aws_region
}

module â€œs3_backendâ€ {
source         = â€œ./modules/s3-backendâ€
aws_region     = var.aws_region
s3_bucket_name = var.s3_bucket_name
tags = {
Environment = var.environment
Project     = â€œterraform-infraâ€
}
}

output â€œbucket_nameâ€ {
value = module.s3_backend.s3_bucket_name
}

output â€œdynamodb_tableâ€ {
value = module.s3_backend.dynamodb_table_name
}
â€™@ | Set-Content â€œ$root/main.tfâ€

â€” variables.tf â€”

@â€™
variable â€œaws_regionâ€ {
description = â€œAWS regionâ€
type        = string
}

variable â€œenvironmentâ€ {
description = â€œDeployment environmentâ€
type        = string
}

variable â€œs3_bucket_nameâ€ {
description = â€œTerraform state bucket nameâ€
type        = string
}
â€™@ | Set-Content â€œ$root/variables.tfâ€

â€” outputs.tf â€”

@â€™
output â€œterraform_backendâ€ {
value = {
bucket         = module.s3_backend.s3_bucket_name
dynamodb_table = module.s3_backend.dynamodb_table_name
region         = var.aws_region
}
}
â€™@ | Set-Content â€œ$root/outputs.tfâ€

â€” backend.tf â€”

@â€™
terraform {
backend â€œs3â€ {}
}
â€™@ | Set-Content â€œ$root/backend.tfâ€

=====================================================

ENVIRONMENT-SPECIFIC TFVARS

=====================================================

@â€™
aws_region      = â€œus-east-1â€
environment     = â€œdevâ€
s3_bucket_name  = â€œmycompany-tfstate-devâ€
â€™@ | Set-Content â€œ$envPath/dev.tfvarsâ€

@â€™
aws_region      = â€œus-east-1â€
environment     = â€œqaâ€
s3_bucket_name  = â€œmycompany-tfstate-qaâ€
â€™@ | Set-Content â€œ$envPath/qa.tfvarsâ€

@â€™
aws_region      = â€œus-east-1â€
environment     = â€œprodâ€
s3_bucket_name  = â€œmycompany-tfstate-prodâ€
â€™@ | Set-Content â€œ$envPath/prod.tfvarsâ€

=====================================================

GITHUB WORKFLOW

=====================================================

@â€™
name: Terraform Infra Setup

on:
push:
branches:
- main
paths:
- â€œ**/.tfâ€
- â€œenvironments/.tfvarsâ€

jobs:
terraform:
runs-on: ubuntu-latest
env:
AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
AWS_DEFAULT_REGION: us-east-1

steps:
  - name: Checkout Code
    uses: actions/checkout@v4

  - name: Setup Terraform
    uses: hashicorp/setup-terraform@v3
    with:
      terraform_version: 1.9.8

  - name: Init
    run: terraform init

  - name: Validate
    run: terraform validate

  - name: Plan (Dev)
    run: terraform plan -var-file=environments/dev.tfvars -out=tfplan

  - name: Apply (Dev)
    run: terraform apply -auto-approve tfplan

â€™@ | Set-Content â€œ$workflowPath/terraform.ymlâ€

Write-Host â€œâœ… Terraform shared structure created successfully at: $rootâ€

---

## ğŸ§¾ Run the Script

```powershell
# Run in PowerShell from your working directory
.\setup-terraform-structure.ps1


â¸»

âœ… Resulting Structure

terraform-infra/
â”œâ”€â”€ main.tf                # Common logic
â”œâ”€â”€ variables.tf           # Shared variable definitions
â”œâ”€â”€ outputs.tf             # Shared outputs
â”œâ”€â”€ backend.tf             # S3 backend placeholder
â”œâ”€â”€ modules/
â”‚   â””â”€â”€ s3-backend/
â”‚       â”œâ”€â”€ main.tf
â”‚       â”œâ”€â”€ variables.tf
â”‚       â”œâ”€â”€ outputs.tf
â”‚       â””â”€â”€ README.md
â”œâ”€â”€ environments/
â”‚   â”œâ”€â”€ dev.tfvars
â”‚   â”œâ”€â”€ qa.tfvars
â”‚   â””â”€â”€ prod.tfvars
â””â”€â”€ .github/
    â””â”€â”€ workflows/
        â””â”€â”€ terraform.yml


â¸»

ğŸ’¡ Usage Example

Initialize & apply for a specific environment:

# Dev
terraform init
terraform plan -var-file=environments/dev.tfvars
terraform apply -var-file=environments/dev.tfvars -auto-approve

# QA
terraform plan -var-file=environments/qa.tfvars
terraform apply -var-file=environments/qa.tfvars -auto-approve


â¸»

Would you like me to extend this script so that it also auto-runs terraform init + plan after creating the files (for immediate test setup)?