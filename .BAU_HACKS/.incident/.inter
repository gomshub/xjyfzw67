Here is the complete updated code that implements the described requirements. It includes an interactive update_comment service that:
	1.	Fetches detailed information from the database.
	2.	Populates the update_comment field in an editable manner in the HTML response.
	3.	Provides options to mark a JIRA issue as resolved interactively.
	4.	Dynamically fetches API tokens from a Kubernetes secret based on the system user passed to the service.
	5.	Generates a well-styled and elegant HTML response file with a full base URL.

1. Kubernetes Secret

Store the API tokens in a Kubernetes secret as a JSON file.

apiVersion: v1
kind: Secret
metadata:
  name: user-api-tokens
  namespace: your-namespace
type: Opaque
data:
  user_tokens.json: |
    eyJhZG1pbiI6ICJ0b2tlbl9mb3JfYWRtaW4iLCAidXNlcm5hbWUxIjogInRva2VuX2Zvcl91c2VyMSIsICJ1c2VybmFtZTIiOiAidG9rZW5fZm9yX3VzZXIyIn0=

The user_tokens.json contains the mapping of usernames to API tokens, encoded as a base64 string.

2. settings.py

This file loads environment variables and handles the logic to fetch API tokens from Kubernetes secrets.

import os
import json

class Config:
    FLASK_ENV = os.getenv("FLASK_ENV", "production")
    SECRET_KEY = os.getenv("SECRET_KEY", "default_secret_key")
    BASE_URL = os.getenv("BASE_URL", "http://localhost:6000")
    KUBE_SECRET_PATH = os.getenv("KUBE_SECRET_PATH", "/var/run/secrets/kubernetes.io/serviceaccount")
    USER_TOKENS_FILE = f"{KUBE_SECRET_PATH}/user_tokens.json"

    @staticmethod
    def get_user_api_token(username):
        """
        Fetch API token for the given username from Kubernetes secrets or a local fallback.
        """
        try:
            if os.path.exists(Config.USER_TOKENS_FILE):
                with open(Config.USER_TOKENS_FILE, "r") as f:
                    tokens = json.load(f)
                return tokens.get(username)
            else:
                raise FileNotFoundError(f"{Config.USER_TOKENS_FILE} not found")
        except Exception as e:
            print(f"Error fetching API token for user {username}: {e}")
            return None

3. db_operations.py

Database operations for fetching JIRA details.

import jaydebeapi

class DBManager:
    def __init__(self, db_url, db_user, db_password, jdbc_driver, driver_path):
        self.db_url = db_url
        self.db_user = db_user
        self.db_password = db_password
        self.jdbc_driver = jdbc_driver
        self.driver_path = driver_path

    def fetch_issues(self):
        """
        Fetch issues from the database.
        """
        query = """
        SELECT jira_number, job_number, summary, criticity, description, 
               comments, recent_comment, update_comment 
        FROM jira_issues
        """
        try:
            conn = jaydebeapi.connect(
                self.jdbc_driver,
                self.db_url,
                [self.db_user, self.db_password],
                self.driver_path
            )
            with conn.cursor() as cursor:
                cursor.execute(query)
                rows = cursor.fetchall()
            return rows
        except Exception as e:
            print(f"Error fetching issues from DB: {e}")
            return []

4. routes.py

The Flask application routes.

from flask import Flask, jsonify, render_template, request
from settings import Config
from db_operations import DBManager

app = Flask(__name__)
app.config.from_object(Config)

# Database configuration
DB_CONFIG = {
    "db_url": "jdbc:oracle:thin:@your_db_host:1521/your_db_service",
    "db_user": "your_db_user",
    "db_password": "your_db_password",
    "jdbc_driver": "oracle.jdbc.OracleDriver",
    "driver_path": "/path/to/ojdbc8.jar"
}
db_manager = DBManager(**DB_CONFIG)

@app.route('/interactive', methods=['POST'])
def interactive_service():
    """
    Handles interactive update comment and resolve status requests.
    """
    username = request.json.get("username")
    if not username:
        return jsonify({"error": "Username not provided"}), 400

    # Fetch API token
    api_token = Config.get_user_api_token(username)
    if not api_token:
        return jsonify({"error": f"API token not found for user {username}"}), 404

    # Fetch issues from DB
    issues = db_manager.fetch_issues()
    if not issues:
        return jsonify({"error": "No issues found in the database"}), 404

    # Render HTML response
    return render_template(
        "interactive.html",
        issues=issues,
        username=username,
        api_token=api_token,
        base_url=Config.BASE_URL
    )

if __name__ == "__main__":
    app.run(debug=True, host="0.0.0.0", port=6000)

5. HTML Template (interactive.html)

Interactive HTML template for updating comments and resolving status.

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive JIRA Update</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
        }
        table {
            border-collapse: collapse;
            width: 100%;
            margin-top: 20px;
        }
        table, th, td {
            border: 1px solid black;
        }
        th, td {
            padding: 8px;
            text-align: left;
        }
        input, button {
            padding: 5px;
            margin: 5px;
        }
    </style>
</head>
<body>
    <h1>Interactive JIRA Update</h1>
    <table>
        <thead>
            <tr>
                <th>JIRA Number</th>
                <th>Job Number</th>
                <th>Summary</th>
                <th>Criticity</th>
                <th>Description</th>
                <th>Comments</th>
                <th>Recent Comment</th>
                <th>Update Comment</th>
                <th>Action</th>
            </tr>
        </thead>
        <tbody>
            {% for issue in issues %}
            <tr>
                <td><a href="https://jira.example.com/browse/{{ issue[0] }}" target="_blank">{{ issue[0] }}</a></td>
                <td><a href="{{ base_url }}/job/{{ issue[1] }}" target="_blank">{{ issue[1] }}</a></td>
                <td>{{ issue[2] }}</td>
                <td>{{ issue[3] }}</td>
                <td>{{ issue[4] }}</td>
                <td>{{ issue[5] }}</td>
                <td>{{ issue[6] }}</td>
                <td><input type="text" value="{{ issue[7] }}" id="comment_{{ issue[0] }}"></td>
                <td>
                    <button onclick="updateComment('{{ issue[0] }}')">Update Comment</button>
                    <button onclick="resolveStatus('{{ issue[0] }}')">Resolve</button>
                </td>
            </tr>
            {% endfor %}
        </tbody>
    </table>

    <script>
        const baseUrl = "{{ base_url }}";

        function updateComment(jiraNumber) {
            const comment = document.getElementById(`comment_${jiraNumber}`).value;
            fetch(`${baseUrl}/update_comment`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ jira_number: jiraNumber, comment })
            })
            .then(response => response.json())
            .then(data => alert(`Comment updated: ${data.status}`))
            .catch(err => console.error(err));
        }

        function resolveStatus(jiraNumber) {
            fetch(`${baseUrl}/resolve_status`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ jira_number: jiraNumber })
            })
            .then(response => response.json())
            .then(data => alert(`Issue resolved: ${data.status}`))
            .catch(err => console.error(err));
        }
    </script>
</body>
</html>

Notes:
	•	The interactive HTML allows users to edit update_comment directly and provides buttons for updating comments and resolving statuses.
	•	The backend dynamically fetches API tokens for the user from Kubernetes secrets.
	•	The base_url ensures all service calls are correctly routed.