

Below is a complete, self‐contained Python example for your sync service. This service:
	1.	Fetches JIRA issues from an API (assumed already fetched into a list).
	2.	Extracts the job name from the issue summary (by removing the first character).
	3.	Determines which Oracle DB to use based on the job name.
	4.	For each issue (uniquely identified by jira_number):
	•	Inserts it if it is not in the DB.
	•	Updates its comments if they differ from those in the DB.
	5.	For issues in the DB that are no longer returned in the filter (and whose status is not already “Resolved”), it updates their status to “Resolved.”
	6.	Returns a JSON response listing the inserted, updated, and resolved issues (each with the jira_number and job_name).

In this example, the DB connections are made using jaydebeapi. (Adjust the DB_CONFIG and JDBC details as needed for your environment.)

sync_service.py

import requests
import jaydebeapi
import json

### Configuration

# JIRA API configuration
JIRA_API_URL = "https://your-jira-instance.atlassian.net/rest/api/2/search"
JIRA_FILTER_ID = "12345"
JIRA_API_TOKEN = "YOUR_JIRA_API_TOKEN"
HEADERS = {
    "Authorization": f"Bearer {JIRA_API_TOKEN}",
    "Content-Type": "application/json"
}

# Oracle DB configuration based on job_name (determines DB environment)
DB_CONFIG = {
    "ENV1": {
        "url": "jdbc:oracle:thin:@//db1_host:1521/db1",
        "username": "user1",
        "password": "pass1"
    },
    "ENV2": {
        "url": "jdbc:oracle:thin:@//db2_host:1521/db2",
        "username": "user2",
        "password": "pass2"
    }
}

JDBC_DRIVER = "oracle.jdbc.driver.OracleDriver"
JAR_PATH = "/path/to/ojdbc6.jar"


### Functions

def get_jira_issues(filter_id):
    """
    Fetches JIRA issues using a JQL filter and returns a list of issues with selected fields.
    Each issue includes:
       - jira_number (the issue key)
       - summary
       - status
       - comments (list of comment bodies)
       - job_name (extracted from summary by removing the first character)
    """
    params = {
        "jql": f"filter={filter_id}",
        "fields": ["summary", "status", "comment"]
    }
    response = requests.get(JIRA_API_URL, headers=HEADERS, params=params)
    if response.status_code != 200:
        raise Exception(f"Error fetching JIRA issues: {response.text}")
    issues = response.json().get("issues", [])
    jira_data = []
    for issue in issues:
        jira_number = issue.get("key")
        summary = issue["fields"].get("summary", "")
        status = issue["fields"]["status"].get("name", "")
        # Extract comment bodies from the comments array, if present
        comments = []
        comment_field = issue["fields"].get("comment", {})
        if "comments" in comment_field:
            comments = [c.get("body", "") for c in comment_field["comments"]]
        job_name = extract_job_name(summary)
        jira_data.append({
            "jira_number": jira_number,
            "summary": summary,
            "status": status,
            "comments": comments,
            "job_name": job_name
        })
    return jira_data

def extract_job_name(summary):
    """
    Extracts the job name from the issue summary by removing the first character.
    Returns an empty string if summary is empty.
    """
    return summary[1:] if summary else ""

def determine_db_env(job_name):
    """
    Determines the database environment based on the job_name.
    For example, if job_name starts with "A", then ENV1; if "B", then ENV2.
    Modify this logic as needed.
    """
    if job_name.startswith("A"):
        return "ENV1"
    elif job_name.startswith("B"):
        return "ENV2"
    else:
        return None

def get_db_issues(jira_numbers, db_env):
    """
    Connects to the Oracle DB (via jaydebeapi) for the given environment and fetches issues
    whose jira_number is in the provided list.
    Returns a dictionary keyed by jira_number with stored comments (as list) and status.
    Assumes the Issues table has columns: jira_number, comments (stored as a JSON string), status.
    """
    db_conf = DB_CONFIG.get(db_env)
    if not db_conf:
        return {}
    conn = jaydebeapi.connect(JDBC_DRIVER, db_conf["url"],
                               [db_conf["username"], db_conf["password"]], JAR_PATH)
    cursor = conn.cursor()
    placeholders = ", ".join(["?"] * len(jira_numbers))
    query = f"SELECT jira_number, comments, status FROM Issues WHERE jira_number IN ({placeholders})"
    cursor.execute(query, jira_numbers)
    results = {}
    for row in cursor.fetchall():
        jira_num = row[0]
        try:
            db_comments = json.loads(row[1])
        except Exception:
            db_comments = []
        status = row[2]
        results[jira_num] = {"comments": db_comments, "status": status}
    cursor.close()
    conn.close()
    return results

def update_database(jira_data):
    """
    Inserts new issues or updates existing ones if the comments have changed.
    Uses jira_number as the unique key.
    Returns a dictionary with "inserted" and "updated" lists containing jira_number and job_name.
    """
    result = {"inserted": [], "updated": []}
    # Process issues grouped by DB environment.
    issues_by_env = {}
    for issue in jira_data:
        db_env = determine_db_env(issue["job_name"])
        if not db_env:
            continue
        issues_by_env.setdefault(db_env, []).append(issue)
    
    for db_env, issues in issues_by_env.items():
        # Get a list of jira_numbers for these issues
        jira_nums = [issue["jira_number"] for issue in issues]
        db_issues = get_db_issues(jira_nums, db_env)
        db_conf = DB_CONFIG[db_env]
        conn = jaydebeapi.connect(JDBC_DRIVER, db_conf["url"],
                                  [db_conf["username"], db_conf["password"]], JAR_PATH)
        cursor = conn.cursor()
        
        for issue in issues:
            jira_num = issue["jira_number"]
            job_name = issue["job_name"]
            new_comments = issue["comments"]
            new_comments_json = json.dumps(new_comments)
            if jira_num in db_issues:
                existing_comments = db_issues[jira_num]["comments"]
                if set(existing_comments) != set(new_comments):
                    cursor.execute("UPDATE Issues SET comments = ? WHERE jira_number = ?", (new_comments_json, jira_num))
                    result["updated"].append({"jira_number": jira_num, "job_name": job_name})
            else:
                cursor.execute("INSERT INTO Issues (jira_number, summary, comments, status, job_name) VALUES (?, ?, ?, ?, ?)",
                               (jira_num, issue["summary"], new_comments_json, issue["status"], job_name))
                result["inserted"].append({"jira_number": jira_num, "job_name": job_name})
        
        conn.commit()
        cursor.close()
        conn.close()
    
    return result

def mark_resolved_issues(jira_numbers_in_filter, db_env):
    """
    Marks issues as "Resolved" in the DB for a given environment if they are not present
    in the JIRA filter result and their status is not already 'Resolved'.
    Returns a list of issues marked as resolved (each with jira_number and job_name).
    """
    db_conf = DB_CONFIG.get(db_env)
    if not db_conf:
        return []
    conn = jaydebeapi.connect(JDBC_DRIVER, db_conf["url"],
                               [db_conf["username"], db_conf["password"]], JAR_PATH)
    cursor = conn.cursor()
    
    # Fetch all issues from the DB for this environment with status not equal to 'Resolved'
    cursor.execute("SELECT jira_number, job_name, status FROM Issues WHERE status <> 'Resolved'")
    issues_in_db = {row[0]: {"job_name": row[1], "status": row[2]} for row in cursor.fetchall()}
    resolved = []
    for jira_num, data in issues_in_db.items():
        if jira_num not in jira_numbers_in_filter:
            cursor.execute("UPDATE Issues SET status = 'Resolved' WHERE jira_number = ?", (jira_num,))
            resolved.append({"jira_number": jira_num, "job_name": data["job_name"]})
            print(f"Marked {jira_num} as Resolved")
    conn.commit()
    cursor.close()
    conn.close()
    return resolved

def sync_issues(filter_id):
    """
    Main sync function:
      - Fetches JIRA issues from API.
      - For each issue, inserts or updates the DB (using jira_number as unique key).
      - For each DB environment, marks issues not present in the filter as 'Resolved'.
      - Returns a JSON object with lists of inserted, updated, and resolved issues.
    """
    jira_data = get_jira_issues(filter_id)
    jira_numbers_in_filter = [issue["jira_number"] for issue in jira_data]
    
    update_result = update_database(jira_data)
    
    # For each DB environment in DB_CONFIG, mark missing issues as Resolved
    resolved_result = []
    for db_env in DB_CONFIG.keys():
        resolved = mark_resolved_issues(jira_numbers_in_filter, db_env)
        resolved_result.extend(resolved)
    
    final_result = {
        "inserted": update_result.get("inserted", []),
        "updated": update_result.get("updated", []),
        "resolved": resolved_result
    }
    return final_result

if __name__ == "__main__":
    filter_id = "12345"  # Example filter ID
    sync_result = sync_issues(filter_id)
    print(json.dumps(sync_result, indent=4))

3️⃣ Explanation
	•	get_jira_issues(filter_id):
	•	Calls the JIRA API using the provided filter.
	•	Extracts relevant fields: jira_number, summary, status, comments.
	•	Uses extract_job_name(summary) to remove the first character and get the job name.
	•	determine_db_env(job_name):
	•	Based on the first letter (or other criteria) of the job name, it returns a key (e.g., “ENV1” or “ENV2”) to select the corresponding DB configuration.
	•	get_db_issues(jira_numbers, db_env):
	•	Connects to the Oracle database for the specified environment.
	•	Queries issues by jira_number.
	•	Returns a dictionary mapping each jira_number to its stored comments (decoded from JSON) and status.
	•	update_database(jira_data):
	•	Iterates over each issue.
	•	For each issue:
	•	If it exists in DB, compares comments (as sets). If they differ, updates the comments.
	•	If not found, inserts the issue.
	•	Collects and returns lists of inserted and updated issues.
	•	mark_resolved_issues(jira_numbers_in_filter, db_env):
	•	For each DB environment, fetches all issues that are not already resolved.
	•	If an issue in the DB is not in the filter result (based on jira_number) and its status is not “Resolved,” updates its status to “Resolved.”
	•	Returns a list of issues (with jira_number and job_name) that were marked as resolved.
	•	sync_issues(filter_id):
	•	Orchestrates the entire sync process:
	1.	Fetch JIRA issues.
	2.	Update/insert issues in the DB.
	3.	Mark missing issues as resolved.
	•	Returns a final JSON object with lists for inserted, updated, and resolved issues.

4️⃣ Final JSON Response Example

{
    "inserted": [
        { "jira_number": "JIRA-1001", "job_name": "A1" },
        { "jira_number": "JIRA-1002", "job_name": "B1" }
    ],
    "updated": [
        { "jira_number": "JIRA-1003", "job_name": "A2" }
    ],
    "resolved": [
        { "jira_number": "JIRA-1004", "job_name": "B2" }
    ]
}

5️⃣ Running the Service
	•	Save the code as sync_service.py.
	•	Run it with:

python3 sync_service.py


	•	The output will be a JSON response printed to the console.

This complete code meets the requirements for syncing JIRA issues to the corresponding Oracle databases using jaydebeapi, based on job name (extracted from the summary), updating comments if changed, inserting new issues, and marking missing issues as resolved—all without deleting any records.


=#=
def mark_resolved_issues(jira_numbers_from_filter, db_env):
    """
    Mark issues as resolved if they exist in the database for the given environment,
    have a status that is not already 'Resolved', and are no longer returned by the JIRA filter.
    
    :param jira_numbers_from_filter: List of jira_numbers that are returned by the JIRA filter.
    :param db_env: The database environment key (e.g., "ENV1" or "ENV2").
    :return: List of dictionaries with 'jira_number' and 'job_name' for issues marked as resolved.
    """
    # Fetch all issues in the DB for this environment
    db_config = DB_CONFIG.get(db_env)
    if not db_config:
        print(f"No DB configuration for environment {db_env}")
        return []
    
    conn = jaydebeapi.connect(JDBC_DRIVER, db_config["url"],
                              [db_config["username"], db_config["password"]], JAR_PATH)
    cursor = conn.cursor()
    
    # Fetch all issues from the DB with status not equal to 'Resolved'
    cursor.execute("SELECT jira_number, status FROM Issues WHERE status <> 'Resolved'")
    issues_in_db = {row[0]: row[1] for row in cursor.fetchall()}
    
    resolved = []
    for jira_number, status in issues_in_db.items():
        if jira_number not in jira_numbers_from_filter:
            # Mark this issue as Resolved because it is not in the JIRA filter
            cursor.execute("UPDATE Issues SET status = 'Resolved' WHERE jira_number = ?", (jira_number,))
            resolved.append({"jira_number": jira_number})
            print(f"Marked {jira_number} as Resolved")
    
    conn.commit()
    cursor.close()
    conn.close()
    return resolved



import jaydebeapi
import json

# Database Configs Based on Job Name
DB_CONFIG = {
    "ENV1": {"url": "jdbc:oracle:thin:@db1_host:1521/db1", "username": "user1", "password": "pass1"},
    "ENV2": {"url": "jdbc:oracle:thin:@db2_host:1521/db2", "username": "user2", "password": "pass2"},
}

JDBC_DRIVER = "oracle.jdbc.OracleDriver"
JAR_PATH = "/path/to/ojdbc.jar"

def determine_db_env(job_name):
    """Determine which database to use based on job_name"""
    if job_name.startswith("A"):
        return "ENV1"
    elif job_name.startswith("B"):
        return "ENV2"
    return None

def get_db_issues(jira_numbers, db_env):
    """Fetch existing issues from the database by jira_number"""
    db_config = DB_CONFIG.get(db_env)
    if not db_config:
        return {}

    conn = jaydebeapi.connect(JDBC_DRIVER, db_config["url"], 
                              [db_config["username"], db_config["password"]], JAR_PATH)
    cursor = conn.cursor()

    placeholders = ', '.join(['?'] * len(jira_numbers))
    query = f"SELECT jira_number, comments, status FROM Issues WHERE jira_number IN ({placeholders})"
    
    cursor.execute(query, jira_numbers)
    db_issues = {row[0]: {"comments": row[1], "status": row[2]} for row in cursor.fetchall()}

    cursor.close()
    conn.close()
    return db_issues

def update_database(jira_data):
    """Insert new issues, update changed comments, and resolve missing issues"""
    result = {"inserted": [], "updated": [], "resolved": []}

    jira_numbers = [issue["jira_number"] for issue in jira_data]
    job_name_map = {issue["jira_number"]: issue["job_name"] for issue in jira_data}

    # Organize JIRA data by database environment
    db_jira_map = {}
    for issue in jira_data:
        db_env = determine_db_env(issue["job_name"])
        if db_env:
            db_jira_map.setdefault(db_env, []).append(issue)

    for db_env, issues in db_jira_map.items():
        db_issues = get_db_issues(jira_numbers, db_env)

        conn = jaydebeapi.connect(JDBC_DRIVER, DB_CONFIG[db_env]["url"], 
                                  [DB_CONFIG[db_env]["username"], DB_CONFIG[db_env]["password"]], JAR_PATH)
        cursor = conn.cursor()

        for issue in issues:
            jira_number = issue["jira_number"]
            job_name = issue["job_name"]
            new_comments = json.dumps(issue["comments"])

            if jira_number in db_issues:
                db_comments = db_issues[jira_number]["comments"]
                if set(db_comments) != set(issue["comments"]):
                    cursor.execute("UPDATE Issues SET comments = ? WHERE jira_number = ?", (new_comments, jira_number))
                    result["updated"].append({"jira_number": jira_number, "job_name": job_name})
            else:
                cursor.execute("INSERT INTO Issues (jira_number, summary, comments, status) VALUES (?, ?, ?, ?)",
                               (jira_number, issue["summary"], new_comments, issue["status"]))
                result["inserted"].append({"jira_number": jira_number, "job_name": job_name})

        conn.commit()
        cursor.close()
        conn.close()

    # Resolve missing issues
    for db_env in DB_CONFIG.keys():
        resolved = mark_resolved_issues(jira_numbers, db_env)
        result["resolved"].extend(resolved)

    return json.dumps(result, indent=4)

def mark_resolved_issues(jira_numbers, db_env):
    """Mark issues as resolved if they are no longer in the JIRA filter"""
    db_issues = get_db_issues(jira_numbers, db_env)
    resolved = []

    conn = jaydebeapi.connect(JDBC_DRIVER, DB_CONFIG[db_env]["url"], 
                              [DB_CONFIG[db_env]["username"], DB_CONFIG[db_env]["password"]], JAR_PATH)
    cursor = conn.cursor()

    for jira_number in db_issues.keys():
        if jira_number not in jira_numbers:
            cursor.execute("UPDATE Issues SET status = 'Resolved' WHERE jira_number = ?", (jira_number,))
            resolved.append({"jira_number": jira_number, "job_name": determine_db_env(jira_number)})

    conn.commit()
    cursor.close()
    conn.close()

    return resolved

if __name__ == "__main__":
    # Example JIRA data
    jira_data = [
        {"jira_number": "JIRA-1001", "summary": "Issue A1", "status": "Open", "comments": ["Initial comment"], "job_name": "A1"},
        {"jira_number": "JIRA-1002", "summary": "Issue B1", "status": "In Progress", "comments": ["Updated comment"], "job_name": "B1"},
        {"jira_number": "JIRA-1003", "summary": "Issue A2", "status": "Open", "comments": [], "job_name": "A2"},
    ]

    result = update_database(jira_data)
    print(result)

🔹 Enhanced Sync Service with JSON Response

The updated script will now:
✔ Return a JSON object with details of:
	•	✅ Inserted incidents
	•	✏ Updated incidents
	•	🔄 Resolved incidents
✔ Include jira_number and job_name in the response

1️⃣ Updated Python Code: sync_service.py

import requests
import jaydebeapi
import json

# JIRA API Config
JIRA_API_URL = "https://your-jira-instance.atlassian.net/rest/api/2/search"
HEADERS = {
    "Authorization": "Bearer YOUR_JIRA_API_TOKEN",
    "Content-Type": "application/json"
}

# Database Connection Config (Based on Job Name)
DB_CONFIG = {
    "ENV1": {"url": "jdbc:oracle:thin:@db1_host:1521/db1", "username": "user1", "password": "pass1"},
    "ENV2": {"url": "jdbc:oracle:thin:@db2_host:1521/db2", "username": "user2", "password": "pass2"},
}

# JDBC Driver
JDBC_DRIVER = "oracle.jdbc.OracleDriver"
JAR_PATH = "/path/to/ojdbc.jar"

def get_jira_issues(filter_id):
    """Fetch JIRA issues from a given filter ID"""
    query = {
        "jql": f"filter={filter_id}",
        "fields": ["summary", "status", "comment"]
    }
    response = requests.get(JIRA_API_URL, headers=HEADERS, params=query)
    
    if response.status_code != 200:
        raise Exception(f"Failed to fetch JIRA issues: {response.text}")

    issues = response.json().get("issues", [])
    jira_data = []

    for issue in issues:
        jira_number = issue["key"]
        summary = issue["fields"]["summary"]
        status = issue["fields"]["status"]["name"]
        comments = [c["body"] for c in issue["fields"].get("comment", {}).get("comments", [])]

        job_name = extract_job_name(summary)
        jira_data.append({
            "jira_number": jira_number,
            "summary": summary,
            "status": status,
            "comments": comments,
            "job_name": job_name
        })

    return jira_data

def extract_job_name(summary):
    """Extract job_name by removing the first character of summary"""
    return summary[1:] if summary else ""

def determine_db_env(job_name):
    """Determine DB environment based on job_name"""
    if job_name.startswith("A"):
        return "ENV1"
    elif job_name.startswith("B"):
        return "ENV2"
    else:
        return None

def get_db_issues(jira_numbers, db_env):
    """Fetch issues from the database based on JIRA numbers"""
    db_config = DB_CONFIG.get(db_env)
    if not db_config:
        return {}

    conn = jaydebeapi.connect(JDBC_DRIVER, db_config["url"], [db_config["username"], db_config["password"]], JAR_PATH)
    cursor = conn.cursor()

    placeholders = ', '.join(['?'] * len(jira_numbers))
    query = f"SELECT jira_number, comments, status FROM Issues WHERE jira_number IN ({placeholders})"
    
    cursor.execute(query, jira_numbers)
    db_issues = {row[0]: {"comments": row[1], "status": row[2]} for row in cursor.fetchall()}

    cursor.close()
    conn.close()
    return db_issues

def update_database(jira_data):
    """Sync JIRA data with the database"""
    result = {"inserted": [], "updated": []}

    for issue in jira_data:
        jira_number = issue["jira_number"]
        job_name = issue["job_name"]
        
        db_env = determine_db_env(job_name)
        if not db_env:
            print(f"Skipping issue {jira_number}, unknown job_name {job_name}")
            continue

        db_issues = get_db_issues([jira_number], db_env)

        conn = jaydebeapi.connect(JDBC_DRIVER, DB_CONFIG[db_env]["url"], 
                                  [DB_CONFIG[db_env]["username"], DB_CONFIG[db_env]["password"]], JAR_PATH)
        cursor = conn.cursor()

        if jira_number in db_issues:
            db_comments = db_issues[jira_number]["comments"]
            if set(db_comments) != set(issue["comments"]):
                # Update comments
                update_query = "UPDATE Issues SET comments = ? WHERE jira_number = ?"
                cursor.execute(update_query, (json.dumps(issue["comments"]), jira_number))
                result["updated"].append({"jira_number": jira_number, "job_name": job_name})
        else:
            # Insert new issue
            insert_query = "INSERT INTO Issues (jira_number, summary, comments, status) VALUES (?, ?, ?, ?)"
            cursor.execute(insert_query, (jira_number, issue["summary"], json.dumps(issue["comments"]), issue["status"]))
            result["inserted"].append({"jira_number": jira_number, "job_name": job_name})

        conn.commit()
        cursor.close()
        conn.close()

    return result

def mark_resolved_issues(jira_numbers, db_env):
    """Mark issues as resolved if they are no longer in the JIRA filter"""
    db_issues = get_db_issues(jira_numbers, db_env)
    resolved = []

    conn = jaydebeapi.connect(JDBC_DRIVER, DB_CONFIG[db_env]["url"], 
                              [DB_CONFIG[db_env]["username"], DB_CONFIG[db_env]["password"]], JAR_PATH)
    cursor = conn.cursor()

    for jira_number in db_issues.keys():
        if jira_number not in jira_numbers:
            update_query = "UPDATE Issues SET status = 'Resolved' WHERE jira_number = ?"
            cursor.execute(update_query, (jira_number,))
            resolved.append({"jira_number": jira_number, "job_name": determine_db_env(jira_number)})

    conn.commit()
    cursor.close()
    conn.close()

    return resolved

def sync_issues(filter_id):
    """Main function to sync JIRA issues"""
    jira_data = get_jira_issues(filter_id)
    unique_jira_numbers = [issue["jira_number"] for issue in jira_data]
    
    final_result = {"inserted": [], "updated": [], "resolved": []}

    for issue in jira_data:
        job_name = issue["job_name"]
        db_env = determine_db_env(job_name)
        if db_env:
            result = update_database([issue])
            final_result["inserted"].extend(result["inserted"])
            final_result["updated"].extend(result["updated"])
    
    for db_env in DB_CONFIG.keys():
        resolved_issues = mark_resolved_issues(unique_jira_numbers, db_env)
        final_result["resolved"].extend(resolved_issues)

    return json.dumps(final_result, indent=4)

if __name__ == "__main__":
    filter_id = "12345"
    sync_result = sync_issues(filter_id)
    print(sync_result)

2️⃣ JSON Response Example

When you run sync_service.py, it will return a structured JSON output like this:

{
    "inserted": [
        { "jira_number": "JIRA-1001", "job_name": "JobA1" },
        { "jira_number": "JIRA-1002", "job_name": "JobB1" }
    ],
    "updated": [
        { "jira_number": "JIRA-1003", "job_name": "JobA2" }
    ],
    "resolved": [
        { "jira_number": "JIRA-1004", "job_name": "JobB2" }
    ]
}

3️⃣ Summary of Enhancements

✔ Structured JSON output
✔ Lists inserted, updated, and resolved issues
✔ Uses jira_number + job_name for identification
✔ More efficient DB operations
✔ Prints final result as JSON for easy debugging

🚀 Final Outcome

✅ New JIRA issues inserted
✅ Updated issues when comments change
✅ Marked missing issues as Resolved
✅ Returns JSON output with jira_number & job_name
✅ Ready to integrate with other services





🔹 Sync Service for JIRA Issues

The sync service will:
✔ Insert JIRA issues from the filter list if not in the DB
✔ Update comments if they have changed
✔ Mark issues as “Resolved” if they are no longer in the filter list
✔ Determine the database environment based on the job name extracted from the summary
✔ Use jira_number as the unique key in the DB
✔ Query issues using jira_number instead of job name

🔹 Steps to Implement
	1.	Extract job_name from summary to determine DB connection
	2.	Fetch JIRA issues from filter list
	3.	Compare with DB issues using jira_number
	4.	Insert new issues if not in DB
	5.	Update comments if they have changed
	6.	Set status to “Resolved” for issues no longer in the filter list

1️⃣ Python Code: Sync JIRA Issues

sync_service.py

import requests
import jaydebeapi
import json

# JIRA API Config
JIRA_API_URL = "https://your-jira-instance.atlassian.net/rest/api/2/search"
HEADERS = {
    "Authorization": "Bearer YOUR_JIRA_API_TOKEN",
    "Content-Type": "application/json"
}

# Database Connection Config (Based on Job Name)
DB_CONFIG = {
    "ENV1": {"url": "jdbc:oracle:thin:@db1_host:1521/db1", "username": "user1", "password": "pass1"},
    "ENV2": {"url": "jdbc:oracle:thin:@db2_host:1521/db2", "username": "user2", "password": "pass2"},
}

# JDBC Driver
JDBC_DRIVER = "oracle.jdbc.OracleDriver"
JAR_PATH = "/path/to/ojdbc.jar"

def get_jira_issues(filter_id):
    """Fetch JIRA issues from a given filter ID"""
    query = {
        "jql": f"filter={filter_id}",
        "fields": ["summary", "status", "comment"]
    }
    response = requests.get(JIRA_API_URL, headers=HEADERS, params=query)
    
    if response.status_code != 200:
        raise Exception(f"Failed to fetch JIRA issues: {response.text}")

    issues = response.json().get("issues", [])
    jira_data = []

    for issue in issues:
        jira_number = issue["key"]
        summary = issue["fields"]["summary"]
        status = issue["fields"]["status"]["name"]
        comments = [c["body"] for c in issue["fields"].get("comment", {}).get("comments", [])]

        job_name = extract_job_name(summary)
        jira_data.append({
            "jira_number": jira_number,
            "summary": summary,
            "status": status,
            "comments": comments,
            "job_name": job_name
        })

    return jira_data

def extract_job_name(summary):
    """Extract job_name by removing the first character of summary"""
    return summary[1:] if summary else ""

def determine_db_env(job_name):
    """Determine DB environment based on job_name"""
    if job_name.startswith("A"):
        return "ENV1"
    elif job_name.startswith("B"):
        return "ENV2"
    else:
        return None

def get_db_issues(jira_numbers, db_env):
    """Fetch issues from the database based on JIRA numbers"""
    db_config = DB_CONFIG.get(db_env)
    if not db_config:
        return {}

    conn = jaydebeapi.connect(JDBC_DRIVER, db_config["url"], [db_config["username"], db_config["password"]], JAR_PATH)
    cursor = conn.cursor()

    placeholders = ', '.join(['?'] * len(jira_numbers))
    query = f"SELECT jira_number, comments, status FROM Issues WHERE jira_number IN ({placeholders})"
    
    cursor.execute(query, jira_numbers)
    db_issues = {row[0]: {"comments": row[1], "status": row[2]} for row in cursor.fetchall()}

    cursor.close()
    conn.close()
    return db_issues

def update_database(jira_data):
    """Sync JIRA data with the database"""
    for issue in jira_data:
        jira_number = issue["jira_number"]
        job_name = issue["job_name"]
        
        db_env = determine_db_env(job_name)
        if not db_env:
            print(f"Skipping issue {jira_number}, unknown job_name {job_name}")
            continue

        db_issues = get_db_issues([jira_number], db_env)

        conn = jaydebeapi.connect(JDBC_DRIVER, DB_CONFIG[db_env]["url"], 
                                  [DB_CONFIG[db_env]["username"], DB_CONFIG[db_env]["password"]], JAR_PATH)
        cursor = conn.cursor()

        if jira_number in db_issues:
            db_comments = db_issues[jira_number]["comments"]
            if set(db_comments) != set(issue["comments"]):
                # Update comments
                update_query = "UPDATE Issues SET comments = ? WHERE jira_number = ?"
                cursor.execute(update_query, (json.dumps(issue["comments"]), jira_number))
                print(f"Updated comments for {jira_number}")

        else:
            # Insert new issue
            insert_query = "INSERT INTO Issues (jira_number, summary, comments, status) VALUES (?, ?, ?, ?)"
            cursor.execute(insert_query, (jira_number, issue["summary"], json.dumps(issue["comments"]), issue["status"]))
            print(f"Inserted new issue {jira_number}")

        conn.commit()
        cursor.close()
        conn.close()

def mark_resolved_issues(jira_numbers, db_env):
    """Mark issues as resolved if they are no longer in the JIRA filter"""
    db_issues = get_db_issues(jira_numbers, db_env)

    conn = jaydebeapi.connect(JDBC_DRIVER, DB_CONFIG[db_env]["url"], 
                              [DB_CONFIG[db_env]["username"], DB_CONFIG[db_env]["password"]], JAR_PATH)
    cursor = conn.cursor()

    for jira_number in db_issues.keys():
        if jira_number not in jira_numbers:
            update_query = "UPDATE Issues SET status = 'Resolved' WHERE jira_number = ?"
            cursor.execute(update_query, (jira_number,))
            print(f"Marked {jira_number} as Resolved")

    conn.commit()
    cursor.close()
    conn.close()

def sync_issues(filter_id):
    """Main function to sync JIRA issues"""
    jira_data = get_jira_issues(filter_id)
    unique_jira_numbers = [issue["jira_number"] for issue in jira_data]
    
    for issue in jira_data:
        job_name = issue["job_name"]
        db_env = determine_db_env(job_name)
        if db_env:
            update_database([issue])
    
    for db_env in DB_CONFIG.keys():
        mark_resolved_issues(unique_jira_numbers, db_env)

if __name__ == "__main__":
    filter_id = "12345"
    sync_issues(filter_id)

2️⃣ Explanation of the Code

📌 JIRA API Fetch

✔ Calls JIRA search API with the filter ID
✔ Extracts jira_number, summary, status, comments
✔ Determines job_name from summary

📌 Database Sync

✔ Determines DB environment based on job_name
✔ Fetches existing issues by jira_number
✔ Inserts new issues if not present
✔ Updates comments if changed
✔ Marks missing issues as “Resolved”

📌 Functions

🔹 get_jira_issues(filter_id) → Fetch JIRA issues
🔹 extract_job_name(summary) → Extract job_name
🔹 determine_db_env(job_name) → Get DB env
🔹 get_db_issues(jira_numbers, db_env) → Fetch DB issues
🔹 update_database(jira_data) → Insert/update JIRA issues
🔹 mark_resolved_issues(jira_numbers, db_env) → Set status to “Resolved”
🔹 sync_issues(filter_id) → Main function

3️⃣ Running the Sync Service

python3 sync_service.py

🚀 Final Outcome

✅ Inserts new JIRA issues into the DB
✅ Updates comments if changed
✅ Marks missing issues as Resolved
✅ Uses job_name to determine DB
✅ Ensures data consistency with JIRA

🔹 JIRA Sync Service Using JayDeBeAPI (Oracle DB)

This implementation connects to an Oracle Database using JayDeBeAPI to:
	1.	Insert new JIRA issues from the filter list.
	2.	Update existing issues if comments have changed.
	3.	Mark issues as “Resolved” if they are no longer in the JIRA filter.
	4.	Determine the database dynamically based on the job name extracted from the issue summary.
	5.	Do not delete any issues.

🔹 Dependencies

Ensure you have jaydebeapi installed and an OJDBC jar for Oracle.

pip install jaydebeapi

🔹 Fetch Issues from JIRA API

import requests
import json

JIRA_URL = "https://your-jira-instance.atlassian.net/rest/api/2/search"
JIRA_FILTER_ID = "12345"
HEADERS = {
    "Authorization": "Bearer YOUR_JIRA_API_TOKEN",
    "Content-Type": "application/json"
}

def get_jira_issues():
    params = {
        "jql": f"filter={JIRA_FILTER_ID}",
        "fields": ["summary", "status", "comment"]
    }
    response = requests.get(JIRA_URL, headers=HEADERS, params=params)
    
    if response.status_code == 200:
        return response.json().get("issues", [])
    else:
        print(f"Error fetching JIRA issues: {response.text}")
        return []

🔹 Determine Database Based on Job Name

Extract job name from summary and select the appropriate Oracle Database.

import jaydebeapi

DB_MAPPING = {
    "JobA": {
        "url": "jdbc:oracle:thin:@//db-a.example.com:1521/service_name",
        "user": "user_a",
        "password": "password_a",
        "driver": "oracle.jdbc.driver.OracleDriver",
        "jar_path": "/app/utils/lib/ojdbc6.jar"
    },
    "JobB": {
        "url": "jdbc:oracle:thin:@//db-b.example.com:1521/service_name",
        "user": "user_b",
        "password": "password_b",
        "driver": "oracle.jdbc.driver.OracleDriver",
        "jar_path": "/app/utils/lib/ojdbc6.jar"
    }
}

def get_db_connection(job_name):
    """ Connect to Oracle DB based on job name """
    db_config = DB_MAPPING.get(job_name, None)
    if not db_config:
        print(f"No database mapping found for job: {job_name}")
        return None
    
    conn = jaydebeapi.connect(
        db_config["driver"],
        db_config["url"],
        [db_config["user"], db_config["password"]],
        db_config["jar_path"]
    )
    return conn

🔹 Sync JIRA Issues with Oracle DB
	•	Compare JIRA issues with database records.
	•	Insert new issues.
	•	Update comments if changed.
	•	Mark missing issues as “Resolved”.

def extract_job_name(summary):
    """ Extract job name by removing first character """
    return summary[1:] if summary else None

def sync_issues():
    jira_issues = get_jira_issues()
    jira_keys = set()

    # Group issues by job_name for database selection
    db_issues_by_job = {}

    for issue in jira_issues:
        issue_key = issue["key"]
        summary = issue["fields"]["summary"]
        comments = issue["fields"]["comment"]["comments"]
        last_comment = comments[-1]["body"] if comments else None
        status = issue["fields"]["status"]["name"]
        job_name = extract_job_name(summary)

        jira_keys.add(issue_key)

        if job_name not in db_issues_by_job:
            db_issues_by_job[job_name] = []

        db_issues_by_job[job_name].append((issue_key, summary, last_comment, status))

    # Process each job_name and update corresponding database
    for job_name, issues in db_issues_by_job.items():
        conn = get_db_connection(job_name)
        if not conn:
            continue

        cursor = conn.cursor()
        
        # Get existing issues from DB
        cursor.execute("SELECT jira_number, comments FROM Issues")
        existing_issues = {row[0]: row[1] for row in cursor.fetchall()}

        for issue_key, summary, last_comment, status in issues:
            if issue_key in existing_issues:
                # Update if comments have changed
                if last_comment != existing_issues[issue_key]:
                    cursor.execute("""
                        UPDATE Issues 
                        SET comments = ?, status = ?
                        WHERE jira_number = ?
                    """, (last_comment, status, issue_key))
            else:
                # Insert new issue
                cursor.execute("""
                    INSERT INTO Issues (jira_number, summary, comments, status)
                    VALUES (?, ?, ?, ?)
                """, (issue_key, summary, last_comment, status))

        # Mark missing issues as "Resolved"
        for existing_issue in existing_issues.keys():
            if existing_issue not in jira_keys:
                cursor.execute("""
                    UPDATE Issues 
                    SET status = 'Resolved' 
                    WHERE jira_number = ?
                """, (existing_issue,))

        conn.commit()
        cursor.close()
        conn.close()

🔹 Automate the Sync with a Shell Script
	•	Runs every 30 minutes via cron job.
	•	Logs sync results.

#!/bin/bash

LOG_FILE="/var/log/jira_sync.log"

echo "Starting JIRA Sync - $(date)" >> $LOG_FILE

# Run Python script
python3 /app/jira_sync.py >> $LOG_FILE 2>&1

echo "JIRA Sync Completed - $(date)" >> $LOG_FILE

🔹 Schedule via Cron Job

Run every 30 minutes:

crontab -e

Add the following:

*/30 * * * * /bin/bash /app/jira_sync.sh

🔹 Summary

✅ Fetch JIRA issues from API
✅ Connect to Oracle DB dynamically using JayDeBeAPI
✅ Insert/update issues based on latest JIRA data
✅ Mark missing issues as “Resolved” without deleting them
✅ Run automatically every 30 minutes

This ensures real-time JIRA synchronization into the Oracle DB efficiently. 🚀