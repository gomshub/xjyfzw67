
To fetch the image version from the GitOps repo for ArgoCD using curl, follow these steps:

ðŸ”¹ 1. Fetch Image Version from values.yaml (GitOps Repo)

ðŸš€ Using curl to Retrieve Raw File Content

If your GitOps repo is hosted on GitHub, GitLab, or Bitbucket, you can retrieve the values.yaml file using curl.

# Define the GitOps repo URL (Replace with actual URL)
GITOPS_URL="https://raw.githubusercontent.com/company/gitops-repo/main/services/my-service/values.yaml"

# Fetch values.yaml content
curl -s $GITOPS_URL | grep "image:"

ðŸ”¹ 2. Extract the Image Version Using awk or sed

Since values.yaml contains:

image: "artifactory.company.com/my-service:20240201010101"

You can extract the image version using:

IMAGE_TAG=$(curl -s $GITOPS_URL | grep "image:" | awk -F ':' '{print $NF}' | tr -d '"')

echo "âœ… Latest image version: $IMAGE_TAG"

	ðŸ”¹ Example Output: âœ… Latest image version: 20240201010101

ðŸ”¹ 3. Fetch Helm Chart Version from Chart.yaml

If you need the Helm Chart version from Chart.yaml:

CHART_URL="https://raw.githubusercontent.com/company/gitops-repo/main/services/my-service/Chart.yaml"

CHART_VERSION=$(curl -s $CHART_URL | grep "version:" | awk '{print $2}')

echo "âœ… Helm Chart version: $CHART_VERSION"

ðŸ”¹ 4. Use Image Version in CI/CD for Deployment

You can now use $IMAGE_TAG in Bamboo CI/CD, Helm upgrade, or Docker pull.

ðŸ”¹ Example: Deploy using Helm

helm upgrade my-service oci://artifactory.company.com/helm-charts \
  --set image="artifactory.company.com/my-service:$IMAGE_TAG"

ðŸŽ¯ Summary
	â€¢	âœ… Retrieve values.yaml using curl
	â€¢	âœ… Extract the latest image version
	â€¢	âœ… Retrieve Chart.yaml for Helm version
	â€¢	âœ… Use it in Helm upgrade or Kubernetes deployment

Let me know if you need additional tweaks! ðŸš€


#!/bin/bash

# Define Image Repository Path
IMAGE_REPO="cr.example.com/images/image_name"

# Get the latest tag from the local Docker images
LATEST_TAG=$(docker images --format "{{.Repository}}:{{.Tag}}" | grep "$IMAGE_REPO" | awk -F: '{print $2}' | sort -V | tail -n1)

# If no tag is found, start with a default
if [[ -z "$LATEST_TAG" ]]; then
    NEW_TAG="1.0.0"
else
    # Extract Major.Minor.Patch version (assumes semantic versioning)
    MAJOR=$(echo $LATEST_TAG | cut -d. -f1)
    MINOR=$(echo $LATEST_TAG | cut -d. -f2)
    PATCH=$(echo $LATEST_TAG | cut -d. -f3)

    # Increment the Patch version
    NEW_PATCH=$((PATCH + 1))
    NEW_TAG="$MAJOR.$MINOR.$NEW_PATCH"
fi

echo "Latest Tag: $LATEST_TAG"
echo "New Tag: $NEW_TAG"

# Build and tag the new image
docker build -t "$IMAGE_REPO:$NEW_TAG" .

# Push the new image
docker push "$IMAGE_REPO:$NEW_TAG"



#!/bin/bash

IMAGE_NAME="your-registry.com/your-image"

# List all images matching the IMAGE_NAME
echo "Available images for $IMAGE_NAME:"
docker images | grep "$IMAGE_NAME"

# Fetch the latest tag by sorting versions
LATEST_TAG=$(docker images --format "{{.Repository}}:{{.Tag}}" | grep "$IMAGE_NAME" | sort -V | tail -n 1)

echo "Latest image found: $LATEST_TAG"

# Pull the latest image if found
if [ -n "$LATEST_TAG" ]; then
    docker pull "$LATEST_TAG"
else
    echo "No image found for $IMAGE_NAME."
fi

====
#!/bin/bash

IMAGE_NAME="your-registry.com/your-image"
LATEST_TAG=$(docker images --format "{{.Tag}}" $IMAGE_NAME | sort -V | tail -n 1)

if [[ -z "$LATEST_TAG" || "$LATEST_TAG" == "latest" ]]; then
    NEW_TAG="1.0.0"
else
    # Increment the patch version (1.0.0 â†’ 1.0.1)
    IFS='.' read -r major minor patch <<< "$LATEST_TAG"
    NEW_TAG="$major.$minor.$((patch + 1))"
fi

echo "Pulling latest image: $IMAGE_NAME:$LATEST_TAG"
docker pull $IMAGE_NAME:$LATEST_TAG

echo "New version will be: $NEW_TAG"

# Tag and push the new version
docker tag $IMAGE_NAME:$LATEST_TAG $IMAGE_NAME:$NEW_TAG
docker push $IMAGE_NAME:$NEW_TAG
===





curl -s "https://registry.example.com/v2/myimage/tags/list" | grep -o '"[0-9]*\.[0-9]*\.[0-9]*"' | sort -Vr | head -n1



ðŸ”„ Implementing Incremental Image & Chart Versioning in Bamboo

To ensure each deployment has a unique version, we will:
âœ… Use incremental versioning for the Docker image and Helm chart.
âœ… Retrieve the last version, increment it, and update values.yaml.
âœ… Automate everything in Bamboo CI/CD.

1ï¸âƒ£ Get the Last Version & Increment It

We will retrieve the latest version number, increment it, and apply it to:
ðŸ”¹ Docker image version
ðŸ”¹ Helm chart version

ðŸ“œ Bash Script to Increment Version

#!/bin/bash

# Get the last image version from the registry
REGISTRY_URL="internal-registry.company.com/jira-app"
LATEST_VERSION=$(curl -s "https://$REGISTRY_URL/v2/jira-app/tags/list" | jq -r '.tags | map(select(test("^[0-9]+\\.[0-9]+\\.[0-9]+$"))) | sort | last')

# If no previous version, start from 1.0.0
if [[ -z "$LATEST_VERSION" ]]; then
    NEW_VERSION="1.0.0"
else
    # Increment the patch version (e.g., 1.0.0 -> 1.0.1)
    IFS='.' read -r major minor patch <<< "$LATEST_VERSION"
    NEW_VERSION="$major.$minor.$((patch+1))"
fi

echo "New Version: $NEW_VERSION"

# Export the new version for use in the Bamboo script
export NEW_VERSION

ðŸ“Œ This script ensures:
âœ… If no version exists, it starts from 1.0.0
âœ… If a version (e.g., 1.0.0) exists, it increments the patch version â†’ 1.0.1
âœ… You can modify it to increment major/minor versions if needed.

2ï¸âƒ£ Build & Push the Docker Image

We now use the incremented version for our Docker image.

docker build -t internal-registry.company.com/jira-app:$NEW_VERSION .
docker push internal-registry.company.com/jira-app:$NEW_VERSION

ðŸ“Œ Ensures each image has a unique tag
âœ… No â€œlatestâ€ conflicts
âœ… Each deployment gets the correct version

3ï¸âƒ£ Update Helm Chart Version

The Helm chart version must match the Docker image version.

# Update Helm chart version in Chart.yaml
sed -i "s/^version:.*/version: $NEW_VERSION/" helm-chart/Chart.yaml

# Update Docker image version in values.yaml
sed -i "s|tag:.*|tag: $NEW_VERSION|" helm-chart/values.yaml

ðŸ“Œ Ensures Helm & Docker versions stay in sync.

4ï¸âƒ£ Package & Push the Helm Chart

helm package helm-chart --version $NEW_VERSION
helm push helm-chart-$NEW_VERSION.tgz internal-artifactory

ðŸ“Œ Each Helm chart has a unique version number
âœ… No overwriting of old charts
âœ… Ensures rollback capability

5ï¸âƒ£ Update ArgoCD GitOps Repo

ArgoCD monitors a GitOps repository for changes in values.yaml.
We must update this file to trigger the deployment.

# Clone GitOps repo
git clone git@github.com:company/argo-cd-config.git
cd argo-cd-config

# Update values.yaml with the new image version
sed -i "s|tag:.*|tag: $NEW_VERSION|" "helm-chart/values.yaml"

# Commit and push changes
git add helm-chart/values.yaml
git commit -m "Updated Jira app image to $NEW_VERSION"
git push origin main

ðŸ“Œ ArgoCD will detect the change and deploy the new version automatically.

6ï¸âƒ£ Trigger ArgoCD Sync (Optional)

ArgoCD automatically syncs, but we can manually trigger a sync.

curl -X POST "https://argocd.company.com/api/v1/applications/jira-app/sync" \
    -H "Authorization: Bearer $ARGOCD_JWT_TOKEN" \
    -H "Content-Type: application/json" \
    -d '{"prune": false, "dryRun": false, "strategy": {"hook": {"force": true}}}'

ðŸ“Œ Ensures the deployment happens immediately instead of waiting for ArgoCDâ€™s sync interval.

ðŸ“Œ Final Bamboo CI/CD Flow

Step	Action
1	Fetch the latest image version from the registry
2	Increment the version number (e.g., 1.0.1 â†’ 1.0.2)
3	Build & push the Docker image with new version
4	Update Helm chart version in Chart.yaml & values.yaml
5	Package & push the Helm chart
6	Update values.yaml in GitOps repo
7	Push changes to Git to trigger ArgoCD
8	ArgoCD deploys the new version automatically

ðŸ”¥ Full Bamboo Script

#!/bin/bash

set -e  # Exit on error

# Fetch latest version & increment it
REGISTRY_URL="internal-registry.company.com/jira-app"
LATEST_VERSION=$(curl -s "https://$REGISTRY_URL/v2/jira-app/tags/list" | jq -r '.tags | map(select(test("^[0-9]+\\.[0-9]+\\.[0-9]+$"))) | sort | last')

if [[ -z "$LATEST_VERSION" ]]; then
    NEW_VERSION="1.0.0"
else
    IFS='.' read -r major minor patch <<< "$LATEST_VERSION"
    NEW_VERSION="$major.$minor.$((patch+1))"
fi

echo "New Version: $NEW_VERSION"

# Login to internal Docker registry
echo "$DOCKER_PASSWORD" | docker login internal-registry.company.com -u "$DOCKER_USERNAME" --password-stdin

# Build & push Docker image
docker build -t internal-registry.company.com/jira-app:$NEW_VERSION .
docker push internal-registry.company.com/jira-app:$NEW_VERSION

# Update Helm chart version
sed -i "s/^version:.*/version: $NEW_VERSION/" helm-chart/Chart.yaml
sed -i "s|tag:.*|tag: $NEW_VERSION|" helm-chart/values.yaml

# Package & push Helm chart
helm package helm-chart --version $NEW_VERSION
helm push helm-chart-$NEW_VERSION.tgz internal-artifactory

# Update ArgoCD GitOps repo
git clone git@github.com:company/argo-cd-config.git
cd argo-cd-config
sed -i "s|tag:.*|tag: $NEW_VERSION|" "helm-chart/values.yaml"
git add helm-chart/values.yaml
git commit -m "Updated Jira app image to $NEW_VERSION"
git push origin main

# Trigger ArgoCD sync
curl -X POST "https://argocd.company.com/api/v1/applications/jira-app/sync" \
    -H "Authorization: Bearer $ARGOCD_JWT_TOKEN" \
    -H "Content-Type: application/json" \
    -d '{"prune": false, "dryRun": false, "strategy": {"hook": {"force": true}}}'

echo "âœ… Deployment successful: Jira app $NEW_VERSION"

ðŸŽ¯ Whatâ€™s Achieved?

âœ”ï¸ Incremental versioning of Docker image & Helm chart.
âœ”ï¸ Helm & Docker versions are always in sync.
âœ”ï¸ Automated GitOps update â†’ triggers ArgoCD.
âœ”ï¸ ArgoCD syncs & deploys the new version seamlessly.

Would you like further customizations? ðŸš€