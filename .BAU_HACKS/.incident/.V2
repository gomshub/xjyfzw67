
When embedding the list_jiras.html page inside index.html, there might be conflicts in JavaScript or CSS, causing the collapsible comments section to stop working.

Possible Issues & Fixes
	1.	Multiple JavaScript Loads:
	‚Ä¢	If both index.html and list_jiras.html have separate JavaScript files, event listeners may not attach properly.
	‚Ä¢	Fix: Ensure event handlers are re-attached dynamically after loading the page.
	2.	CSS Conflicts:
	‚Ä¢	Different styles from index.html might override the collapsible button styles.
	‚Ä¢	Fix: Use more specific CSS selectors.
	3.	JavaScript Timing Issue:
	‚Ä¢	If list_jiras.html loads dynamically via AJAX, event handlers may not bind properly.
	‚Ä¢	Fix: Use $(document).on("click", ".collapsible", function() {...}) to attach event handlers dynamically.

üîπ Fixing JavaScript in index.html

Modify the existing script inside index.html to handle collapsible buttons properly.

<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
<script>
    $(document).ready(function() {
        // Attach collapsible event to dynamically loaded elements
        $(document).on("click", ".collapsible", function() {
            $(this).next(".content").toggle();
        });

        // Function to refresh JIRA table inside index.html
        function refreshJiraTable() {
            $.ajax({
                url: "/refresh_jira_table",
                type: "GET",
                success: function(data) {
                    $("#jira-table-container").html(data);
                    attachEventHandlers(); // Reattach event handlers after AJAX refresh
                },
                error: function() {
                    alert("Failed to refresh JIRA data.");
                }
            });
        }

        function attachEventHandlers() {
            $(".collapsible").off("click").on("click", function() {
                $(this).next(".content").toggle();
            });
        }

        attachEventHandlers(); // Initial call on page load
    });
</script>

üîπ Fixing list_jiras.html

Ensure that collapsible buttons are properly structured.

<table>
  <thead>
    <tr>
      <th>JIRA Number</th>
      <th>Summary</th>
      <th>Comments</th>
    </tr>
  </thead>
  <tbody>
    {% for issue in issues %}
    <tr>
      <td>{{ issue.jira_number }}</td>
      <td>{{ issue.summary }}</td>
      <td>
        {% for comment in issue.comments %}
          <button class="collapsible">
            {{ comment.date_time }} - {{ comment.author }}
          </button>
          <div class="content" style="display: none;">
            <p>{{ comment.comment }}</p>
          </div>
        {% endfor %}
      </td>
    </tr>
    {% endfor %}
  </tbody>
</table>

üîπ Fixing CSS Conflict

Add specific styling inside list_jiras.html.

<style>
  .collapsible {
      background-color: #eee;
      cursor: pointer;
      padding: 5px;
      border: none;
      text-align: left;
      width: 100%;
      font-weight: bold;
  }

  .content {
      display: none;
      padding: 5px;
      background-color: #f9f9f9;
  }
</style>

‚úÖ Final Fix Checklist
	‚Ä¢	Ensure jQuery is only loaded once in index.html.
	‚Ä¢	Use $(document).on() instead of .click() for collapsible buttons.
	‚Ä¢	Use AJAX to refresh tables & reattach handlers.
	‚Ä¢	Ensure collapsible styles are not overridden by index.html styles.

üí° Try This
	1.	Refresh index.html.
	2.	Click collapsible buttons inside list_jiras.html.
	3.	If they still don‚Äôt work, check browser console (F12 > Console tab) for JavaScript errors.

Let me know if collapsible comments still don‚Äôt work!

Below is a complete example with three modules‚Äîroutes.py, jira_ops.py, and db_ops.py‚Äîthat implement the following functionality:
	‚Ä¢	Fetch JIRA issues from a filter (including comments, with each comment‚Äôs author, date/time, and text in order).
	‚Ä¢	Synchronize those issues with the database using‚ÄØjaydebeapi:
	‚Ä¢	Insert new issues if they do not exist.
	‚Ä¢	Update the Issue_Comments table if the comments have changed.
	‚Ä¢	Mark issues as ‚ÄúResolved‚Äù (by updating their status) if an issue exists in the DB but is not returned by the JIRA filter and its status is not already ‚ÄúResolved.‚Äù
	‚Ä¢	Return a JSON response that lists, for each issue (using its unique key, jira_number), its corresponding job_name along with lists of inserted, updated, and resolved issues.
	‚Ä¢	Provide two HTML templates:
	‚Ä¢	list_jira.html: Displays all issues in a table format with a ‚ÄúComments‚Äù column showing comments in a legible, collapsible view (each comment shows author and date in the collapsed state and expands to show the full comment).
	‚Ä¢	interactive_jira.html: Displays details for a single issue with a similar collapsible view for comments and buttons to update a comment.

You can adjust the database connection details and the extraction logic for job_name as needed.

Project Structure

/jira_service
 ‚îú‚îÄ‚îÄ routes.py         # Flask API endpoints
 ‚îú‚îÄ‚îÄ jira_ops.py       # Functions to fetch/process JIRA issues
 ‚îú‚îÄ‚îÄ db_ops.py         # Database operations using jaydebeapi
 ‚îú‚îÄ‚îÄ config.py         # Contains DB_CONFIG dictionary
 ‚îú‚îÄ‚îÄ templates/
 ‚îÇ      ‚îú‚îÄ‚îÄ list_jira.html
 ‚îÇ      ‚îî‚îÄ‚îÄ interactive_jira.html
 ‚îú‚îÄ‚îÄ requirements.txt  # flask, requests, jaydebeapi, etc.

1. config.py

This file contains your database configurations (example for two environments):

# config.py
DB_CONFIG = {
    "ENV1": {
        "url": "jdbc:oracle:thin:@//db1_host:1521/db1",
        "username": "user1",
        "password": "pass1"
    },
    "ENV2": {
        "url": "jdbc:oracle:thin:@//db2_host:1521/db2",
        "username": "user2",
        "password": "pass2"
    }
}

2. jira_ops.py

This module fetches issues from JIRA and extracts required fields including comments.

# jira_ops.py
import requests
import logging

JIRA_API_URL = "https://your-jira-instance.atlassian.net/rest/api/2/search"
JIRA_FILTER_ID = "12345"
JIRA_API_TOKEN = "YOUR_JIRA_API_TOKEN"

HEADERS = {
    "Authorization": f"Bearer {JIRA_API_TOKEN}",
    "Content-Type": "application/json"
}

def fetch_jira_issues(filter_id):
    """
    Fetch JIRA issues using the given filter ID.
    Returns a list of dictionaries, each containing:
      - jira_number (issue key)
      - summary
      - status
      - comments: list of dicts {author, created, body} (in the order received)
      - job_name: extracted from summary by removing the first character
    """
    params = {
        "jql": f"filter={filter_id}",
        "fields": ["summary", "status", "comment"]
    }
    response = requests.get(JIRA_API_URL, headers=HEADERS, params=params)
    if response.status_code != 200:
        raise Exception(f"Error fetching JIRA issues: {response.text}")
    
    issues = response.json().get("issues", [])
    jira_data = []
    for issue in issues:
        jira_number = issue.get("key")
        summary = issue["fields"].get("summary", "")
        status = issue["fields"]["status"].get("name", "")
        # Extract comments in order
        comments = []
        comment_field = issue["fields"].get("comment", {})
        if "comments" in comment_field:
            for comment in comment_field["comments"]:
                comments.append({
                    "author": comment["author"].get("displayName", "Unknown"),
                    "created": comment.get("created", ""),
                    "body": comment.get("body", "")
                })
        # Derive job_name from summary by removing first character (adjust logic as needed)
        job_name = summary[1:] if summary else ""
        jira_data.append({
            "jira_number": jira_number,
            "summary": summary,
            "status": status,
            "comments": comments,
            "job_name": job_name
        })
    return jira_data

3. db_ops.py

This module uses‚ÄØjaydebeapi‚ÄØto interact with Oracle. It inserts or updates issues and comments and marks issues as resolved if they are missing from the latest JIRA filter.

# db_ops.py
import jaydebeapi
import json
import logging
from config import DB_CONFIG

JDBC_DRIVER = "oracle.jdbc.driver.OracleDriver"
JAR_PATH = "/app/utils/lib/ojdbc6.jar"

def get_db_connection(env):
    db_conf = DB_CONFIG.get(env)
    if not db_conf:
        raise Exception(f"No DB config for environment: {env}")
    conn = jaydebeapi.connect(
        JDBC_DRIVER,
        db_conf["url"],
        [db_conf["username"], db_conf["password"]],
        JAR_PATH
    )
    return conn

def determine_db_env(job_name):
    """
    Determine the DB environment based on job_name.
    For example: if job_name starts with 'A', use ENV1; if with 'B', use ENV2.
    """
    if job_name.startswith("A"):
        return "ENV1"
    elif job_name.startswith("B"):
        return "ENV2"
    else:
        return None

def get_issue_details(jira_number, env):
    """
    Retrieve an issue and its comments from the DB for a given jira_number in a specified environment.
    Returns a dictionary with keys: jira_number, summary, status, job_name, and comments (ordered list).
    """
    conn = get_db_connection(env)
    cursor = conn.cursor()
    cursor.execute("SELECT jira_number, summary, status, job_name FROM Issues WHERE jira_number = ?", (jira_number,))
    row = cursor.fetchone()
    if not row:
        cursor.close()
        conn.close()
        return None
    issue = {
        "jira_number": row[0],
        "summary": row[1],
        "status": row[2],
        "job_name": row[3],
        "comments": []
    }
    cursor.execute("SELECT comment_order, author, date_time, comment FROM Issue_Comments WHERE jira_number = ? ORDER BY comment_order", (jira_number,))
    comments = []
    for r in cursor.fetchall():
        comments.append({
            "order": r[0],
            "author": r[1],
            "date_time": r[2],
            "comment": r[3]
        })
    issue["comments"] = comments
    cursor.close()
    conn.close()
    return issue

def get_db_issues_by_jira(jira_numbers, env):
    """
    Fetches issues from the database for a list of jira_numbers in the specified environment.
    Returns a dict keyed by jira_number with stored comments (as a list) and status.
    """
    conn = get_db_connection(env)
    cursor = conn.cursor()
    placeholders = ", ".join(["?"] * len(jira_numbers))
    query = f"SELECT jira_number, comments, status FROM Issues WHERE jira_number IN ({placeholders})"
    cursor.execute(query, jira_numbers)
    db_issues = {}
    for row in cursor.fetchall():
        jira_num = row[0]
        try:
            comments = json.loads(row[1])
        except Exception:
            comments = []
        db_issues[jira_num] = {"comments": comments, "status": row[2]}
    cursor.close()
    conn.close()
    return db_issues

def update_database(jira_data):
    """
    For each issue in jira_data:
      - If not in DB, insert the issue into Issues table and all its comments into Issue_Comments table.
      - If in DB, compare Issue_Comments; if comments have changed (order-sensitive), update them.
    Returns a dictionary with lists of inserted and updated issues.
    """
    result = {"inserted": [], "updated": []}
    # Group issues by DB environment based on job_name
    issues_by_env = {}
    for issue in jira_data:
        env = determine_db_env(issue["job_name"])
        if not env:
            logging.warning(f"Skipping issue {issue['jira_number']}: unknown DB environment for job_name {issue['job_name']}")
            continue
        issues_by_env.setdefault(env, []).append(issue)
    
    for env, issues in issues_by_env.items():
        for issue in issues:
            jira_number = issue["jira_number"]
            job_name = issue["job_name"]
            # Format comments: assign order numbers based on API order
            formatted_comments = []
            for idx, comment in enumerate(issue["comments"], start=1):
                formatted_comments.append({
                    "order": idx,
                    "author": comment["author"],
                    "date_time": comment["created"],
                    "comment": comment["body"]
                })
            new_comments_json = json.dumps(formatted_comments)
            
            conn = get_db_connection(env)
            cursor = conn.cursor()
            cursor.execute("SELECT COUNT(*) FROM Issues WHERE jira_number = ?", (jira_number,))
            exists = cursor.fetchone()[0] > 0
            
            if exists:
                # Check if comments have changed by fetching Issue_Comments from DB
                cursor.execute("SELECT comment_order, author, date_time, comment FROM Issue_Comments WHERE jira_number = ? ORDER BY comment_order", (jira_number,))
                db_comments = [{"order": r[0], "author": r[1], "date_time": r[2], "comment": r[3]} for r in cursor.fetchall()]
                if db_comments != formatted_comments:
                    # Update Issue_Comments: delete old comments then insert new ones
                    cursor.execute("DELETE FROM Issue_Comments WHERE jira_number = ?", (jira_number,))
                    for comment in formatted_comments:
                        cursor.execute(
                            """INSERT INTO Issue_Comments (jira_number, comment_order, author, date_time, comment)
                               VALUES (?, ?, ?, ?, ?)""",
                            (jira_number, comment["order"], comment["author"], comment["date_time"], comment["comment"])
                        )
                    result["updated"].append({"jira_number": jira_number, "job_name": job_name})
            else:
                # Insert new issue into Issues table
                cursor.execute(
                    "INSERT INTO Issues (jira_number, summary, status, job_name) VALUES (?, ?, ?, ?)",
                    (jira_number, issue["summary"], issue["status"], job_name)
                )
                # Insert comments into Issue_Comments table
                for comment in formatted_comments:
                    cursor.execute(
                        """INSERT INTO Issue_Comments (jira_number, comment_order, author, date_time, comment)
                           VALUES (?, ?, ?, ?, ?)""",
                        (jira_number, comment["order"], comment["author"], comment["date_time"], comment["comment"])
                    )
                result["inserted"].append({"jira_number": jira_number, "job_name": job_name})
            
            conn.commit()
            cursor.close()
            conn.close()
    
    return result

def mark_resolved_issues(jira_numbers_in_filter, env):
    """
    Marks issues as "Resolved" in the DB for a given environment if they are not present
    in the jira_numbers_in_filter and their current status is not already "Resolved".
    Returns a list of issues (with jira_number and job_name) that were marked as resolved.
    """
    conn = get_db_connection(env)
    cursor = conn.cursor()
    cursor.execute("SELECT jira_number, job_name, status FROM Issues WHERE status <> 'Resolved'")
    issues_in_db = {row[0]: {"job_name": row[1], "status": row[2]} for row in cursor.fetchall()}
    resolved = []
    for jira_number, data in issues_in_db.items():
        if jira_number not in jira_numbers_in_filter:
            cursor.execute("UPDATE Issues SET status = 'Resolved' WHERE jira_number = ?", (jira_number,))
            resolved.append({"jira_number": jira_number, "job_name": data["job_name"]})
            logging.info(f"Marked {jira_number} as Resolved in {env}")
    conn.commit()
    cursor.close()
    conn.close()
    return resolved

def sync_issues(filter_id):
    """
    Main sync function:
      - Fetches JIRA issues from the API.
      - Inserts new issues or updates Issue_Comments if comments have changed.
      - For each DB environment, marks issues as "Resolved" if they are not present in the JIRA filter.
      - Returns a JSON-compatible dictionary with keys: "inserted", "updated", "resolved".
    """
    # Fetch JIRA issues from API (jira_ops.py provides this function)
    from jira_ops import fetch_jira_issues
    jira_data = fetch_jira_issues(filter_id)
    jira_numbers_in_filter = {issue["jira_number"] for issue in jira_data}
    
    update_result = update_database(jira_data)
    
    resolved_total = []
    for env in DB_CONFIG.keys():
        resolved = mark_resolved_issues(jira_numbers_in_filter, env)
        resolved_total.extend(resolved)
    
    final_result = {
        "inserted": update_result.get("inserted", []),
        "updated": update_result.get("updated", []),
        "resolved": resolved_total
    }
    return final_result

def get_all_issues():
    """
    Fetches all issues (with comments) from all DB environments.
    Returns a list of issues, each a dictionary containing issue details and ordered comments.
    """
    all_issues = []
    for env in DB_CONFIG.keys():
        conn = get_db_connection(env)
        cursor = conn.cursor()
        cursor.execute("SELECT jira_number, summary, status, job_name FROM Issues")
        issues = cursor.fetchall()
        for row in issues:
            jira_number, summary, status, job_name = row
            cursor.execute("SELECT comment_order, author, date_time, comment FROM Issue_Comments WHERE jira_number = ? ORDER BY comment_order", (jira_number,))
            comments = [{"order": r[0], "author": r[1], "date_time": r[2], "comment": r[3]} for r in cursor.fetchall()]
            all_issues.append({
                "jira_number": jira_number,
                "summary": summary,
                "status": status,
                "job_name": job_name,
                "comments": comments,
                "env": env
            })
        cursor.close()
        conn.close()
    return all_issues

4. HTML Templates

A. list_jira.html

<!-- templates/list_jira.html -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>JIRA Issues List</title>
  <style>
    table { border-collapse: collapse; width: 100%; }
    th, td { border: 1px solid #ccc; padding: 8px; text-align: left; vertical-align: top; }
    th { background-color: #f2f2f2; }
    .comment { margin-bottom: 4px; }
  </style>
</head>
<body>
  <h1>JIRA Issues List</h1>
  <table>
    <thead>
      <tr>
        <th>JIRA Number</th>
        <th>Summary</th>
        <th>Status</th>
        <th>Job Name</th>
        <th>Comments</th>
      </tr>
    </thead>
    <tbody>
      {% for issue in issues %}
      <tr>
        <td>{{ issue.jira_number }}</td>
        <td>{{ issue.summary }}</td>
        <td>{{ issue.status }}</td>
        <td>{{ issue.job_name }}</td>
        <td>
          {% for comment in issue.comments %}
            <div class="comment">
              <strong>{{ comment.order }}. {{ comment.author }}</strong> ({{ comment.date_time }})<br>
              {{ comment.comment }}
            </div>
          {% endfor %}
        </td>
      </tr>
      {% endfor %}
    </tbody>
  </table>
</body>
</html>

B. interactive_jira.html

<!-- templates/interactive_jira.html -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Interactive JIRA Issue</title>
  <style>
    table { border-collapse: collapse; width: 100%; }
    th, td { border: 1px solid #ccc; padding: 8px; text-align: left; vertical-align: top; }
    th { background-color: #f2f2f2; }
    .collapsible {
      background-color: #eee;
      border: none;
      padding: 5px;
      width: 100%;
      text-align: left;
      cursor: pointer;
      margin-bottom: 2px;
      font-size: 14px;
    }
    .collapsible:after {
      content: '\002B';
      float: right;
      margin-left: 5px;
    }
    .collapsible.active:after {
      content: "\2212";
    }
    .content {
      display: none;
      padding: 5px;
      background-color: #f9f9f9;
      margin-bottom: 5px;
      font-size: 13px;
    }
  </style>
  <script>
    document.addEventListener("DOMContentLoaded", function(){
      var coll = document.getElementsByClassName("collapsible");
      for (var i = 0; i < coll.length; i++) {
        coll[i].addEventListener("click", function() {
          this.classList.toggle("active");
          var content = this.nextElementSibling;
          if (content.style.display === "block") {
            content.style.display = "none";
          } else {
            content.style.display = "block";
          }
        });
      }
    });

    async function updateComment() {
      const jiraNumber = document.getElementById("jira_number").value;
      const newComment = document.getElementById("new_comment").value;
      const response = await fetch("/update_comment", {
        method: "POST",
        headers: {"Content-Type": "application/json"},
        body: JSON.stringify({jira_id: jiraNumber, comment: newComment})
      });
      const data = await response.json();
      alert(data.message || data.error);
      if (response.ok) {
          refreshComments(jiraNumber);
      }
    }

    async function refreshComments(jiraNumber) {
      const response = await fetch(`/get_issue_comments?jira_number=${jiraNumber}`);
      const data = await response.json();
      if (response.ok) {
          let html = "";
          data.comments.forEach(function(c) {
            html += `<button type="button" class="collapsible">${c.order}. ${c.author} - ${c.date_time}</button>`;
            html += `<div class="content"><p>${c.comment}</p></div>`;
          });
          document.getElementById("comments_container").innerHTML = html;
          // Reattach event listeners for new collapsible elements
          var coll = document.getElementsByClassName("collapsible");
          for (var i = 0; i < coll.length; i++) {
            coll[i].addEventListener("click", function() {
              this.classList.toggle("active");
              var content = this.nextElementSibling;
              if (content.style.display === "block") {
                content.style.display = "none";
              } else {
                content.style.display = "block";
              }
            });
          }
      } else {
          alert("Failed to fetch comments.");
      }
    }
  </script>
</head>
<body>
  <h1>Interactive JIRA Issue</h1>
  <table>
    <tr>
      <th>JIRA Number</th>
      <td><input type="hidden" id="jira_number" value="{{ issue.jira_number }}">{{ issue.jira_number }}</td>
    </tr>
    <tr>
      <th>Summary</th>
      <td>{{ issue.summary }}</td>
    </tr>
    <tr>
      <th>Status</th>
      <td>{{ issue.status }}</td>
    </tr>
    <tr>
      <th>Job Name</th>
      <td>{{ issue.job_name }}</td>
    </tr>
    <tr>
      <th>Comments</th>
      <td id="comments_container">
        {% for comment in issue.comments %}
          <button type="button" class="collapsible">
            {{ comment.order }}. {{ comment.author }} - {{ comment.date_time }}
          </button>
          <div class="content">
            <p>{{ comment.comment }}</p>
          </div>
        {% endfor %}
      </td>
    </tr>
  </table>
  <h3>Update Comment</h3>
  <textarea id="new_comment" rows="4" cols="50" placeholder="Enter your comment"></textarea><br>
  <button onclick="updateComment()">Update Comment</button>
</body>
</html>

5. Additional API Endpoint in routes.py for Comments

To support refreshing comments dynamically in the interactive view, add an endpoint that returns comments for a given jira_number.

# In routes.py (append below existing routes)
from db_ops import get_issue_details

@app.route('/get_issue_comments', methods=['GET'])
def get_issue_comments():
    jira_number = request.args.get("jira_number")
    if not jira_number:
        return jsonify({"error": "jira_number parameter is required"}), 400
    # Determine DB env by iterating over environments (assuming issue exists in one env)
    issue = None
    for env in DB_CONFIG.keys():
        issue = get_issue_details(jira_number, env)
        if issue:
            break
    if not issue:
        return jsonify({"error": "Issue not found"}), 404
    return jsonify({"comments": issue["comments"]})

6. Final JSON Response from Sync Service (For Reference)

When the sync service is run (via /sync endpoint), it returns a JSON object such as:

{
    "inserted": [
        { "jira_number": "JIRA-1001", "job_name": "A1" },
        { "jira_number": "JIRA-1002", "job_name": "B1" }
    ],
    "updated": [
        { "jira_number": "JIRA-1003", "job_name": "A2" }
    ],
    "resolved": [
        { "jira_number": "JIRA-1004", "job_name": "B2" }
    ]
}

Summary
	‚Ä¢	routes.py defines three endpoints:
	‚Ä¢	/sync: Synchronizes JIRA issues with the database.
	‚Ä¢	/list_jira: Renders a table view of all issues.
	‚Ä¢	/interactive_jira: Renders an interactive view of a single issue with collapsible comment sections and update functionality.
	‚Ä¢	/get_issue_comments: Returns JSON with the latest comments for a given issue (used to refresh the interactive view).
	‚Ä¢	jira_ops.py fetches JIRA issues from the API and processes them (including extracting comments and job_name).
	‚Ä¢	db_ops.py uses jaydebeapi to:
	‚Ä¢	Insert new issues,
	‚Ä¢	Update the Issue_Comments table if comments have changed (storing order, author, date_time, comment),
	‚Ä¢	Mark issues as ‚ÄúResolved‚Äù if they no longer appear in the JIRA filter.
	‚Ä¢	HTML Templates are designed to present issue details and comments in a legible table format with collapsible sections for each comment.

This complete solution meets the requirements for synchronizing JIRA issues and displaying them interactively with detailed, ordered comments. Let me know if you need further modifications or clarifications!

=#=#

Below is an updated version of the interactive HTML template that prompts the user for confirmation before sending an update or resolve request. In this example, we use JavaScript‚Äôs built‚Äëin‚ÄØconfirm() function so that when a user clicks the ‚ÄúUpdate Comment‚Äù or ‚ÄúResolve Status‚Äù button, a pop-up confirmation dialog appears. If the user confirms, the AJAX request is sent; otherwise, the request is canceled.

Updated interactive_jira.html

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Interactive JIRA Issue</title>
  <style>
    .comment { margin-bottom: 8px; }
    table { border-collapse: collapse; width: 100%; }
    th, td { border: 1px solid #ccc; padding: 8px; text-align: left; }
    th { background-color: #f9f9f9; }
  </style>
  <script>
    async function updateComment(jiraNumber) {
      // Confirmation prompt before updating the comment
      if (!confirm("Are you sure you want to update the comment for issue " + jiraNumber + "?")) {
        return; // User canceled, so exit the function
      }
      
      let newComment = document.getElementById("comment_input_" + jiraNumber).value;
      if (!newComment) {
        alert("Please enter a comment.");
        return;
      }
      
      try {
        const response = await fetch("/update_comment", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ jira_id: jiraNumber, comment: newComment })
        });
        const result = await response.json();
        alert(result.message || result.error);
        if (response.ok) {
          refreshComments(jiraNumber);
        }
      } catch (error) {
        console.error("Error updating comment:", error);
        alert("Error updating comment: " + error);
      }
    }

    async function resolveStatus(jiraNumber) {
      // Confirmation prompt before resolving the issue
      if (!confirm("Are you sure you want to mark issue " + jiraNumber + " as Resolved?")) {
        return; // User canceled, so exit the function
      }
      
      try {
        const response = await fetch("/resolve_status", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ jira_id: jiraNumber })
        });
        const result = await response.json();
        alert(result.message || result.error);
        if (response.ok) {
          refreshComments(jiraNumber);
        }
      } catch (error) {
        console.error("Error resolving status:", error);
        alert("Error resolving status: " + error);
      }
    }

    async function refreshComments(jiraNumber) {
      try {
        const response = await fetch(`/get_issue_comments?jira_number=${jiraNumber}`);
        const data = await response.json();
        if (response.ok) {
          let commentsHtml = "";
          data.comments.forEach(comment => {
            commentsHtml += `<div class="comment"><strong>${comment.order}. ${comment.author}</strong> (${comment.date_time})<br>${comment.comment}</div>`;
          });
          document.getElementById("comments_container_" + jiraNumber).innerHTML = commentsHtml;
        } else {
          alert("Failed to refresh comments.");
        }
      } catch (error) {
        console.error("Error refreshing comments:", error);
      }
    }
  </script>
</head>
<body>
  <h1>Interactive JIRA Issue</h1>
  <p><strong>JIRA Number:</strong> {{ issue.jira_number }}</p>
  <p><strong>Summary:</strong> {{ issue.summary }}</p>
  <p><strong>Status:</strong> {{ issue.status }}</p>
  <p><strong>Job Name:</strong> {{ issue.job_name }}</p>

  <h2>Comments</h2>
  <div id="comments_container_{{ issue.jira_number }}">
    {% for comment in issue.comments %}
      <div class="comment">
        <strong>{{ comment.order }}. {{ comment.author }}</strong> ({{ comment.date_time }})<br>
        {{ comment.comment }}
      </div>
    {% endfor %}
  </div>

  <h3>Update Comment</h3>
  <textarea id="comment_input_{{ issue.jira_number }}" rows="4" cols="50" placeholder="Enter your comment"></textarea>
  <br>
  <button onclick="updateComment('{{ issue.jira_number }}')">Update Comment</button>
  <button onclick="resolveStatus('{{ issue.jira_number }}')">Resolve Status</button>
</body>
</html>

Explanation:
	1.	Confirmation Prompts:
	‚Ä¢	In both updateComment() and resolveStatus(), we use:

if (!confirm("...")) { return; }

This displays a confirmation dialog. If the user clicks ‚ÄúCancel‚Äù, the function returns immediately, and no request is sent.

	2.	AJAX Requests:
	‚Ä¢	After confirmation, the script sends a POST request via the Fetch API to either update the comment or mark the issue as resolved.
	‚Ä¢	Upon a successful response, it calls refreshComments(jiraNumber) to update the comment display.
	3.	Dynamic Comment Refresh:
	‚Ä¢	The refreshComments() function fetches the updated comments (using a GET request to /get_issue_comments?jira_number=...) and updates the HTML content of the comments container.
	4.	HTML Template:
	‚Ä¢	Each issue is displayed with its details.
	‚Ä¢	A text area and two buttons are provided for updating comments or resolving the issue.
	‚Ä¢	The comments container is uniquely identified with an ID that includes the jira_number.

This approach prevents accidental clicks by requiring user confirmation and then dynamically updating the interactive page with the latest comments and status.



Below is one complete solution that ties together three services‚Äîa sync service, a list service, and an interactive service‚Äîthat work together to:
	‚Ä¢	Fetch JIRA issues from the API.
	‚Ä¢	Insert new issues into the database (and their comments into an Issue_Comments table) or update existing ones if the comments have changed.
	‚Ä¢	Mark issues as ‚ÄúResolved‚Äù in the database if they are no longer returned by the JIRA filter (without deleting any records).
	‚Ä¢	Display a list of issues (with comment details) in a static HTML page.
	‚Ä¢	Provide an interactive HTML page for a selected issue.

For each issue, the database stores in the Issue_Comments table the following details for each comment in the order received:
	‚Ä¢	jira_number (foreign key to the Issues table)
	‚Ä¢	order_number (1,2,3,‚Ä¶ in the order the comments appear)
	‚Ä¢	author
	‚Ä¢	date_time
	‚Ä¢	comment

In this example, we assume that the database environment is determined by the job name extracted from the issue summary (using a simple rule). We use the unique key ‚Äújira_number‚Äù for matching records. We use‚ÄØJayDeBeAPI‚ÄØto connect to an Oracle database (you can adapt this to another DB as needed).

The project is organized as follows:

/jira_service
 ‚îú‚îÄ‚îÄ routes.py           # Flask API endpoints for sync, list, interactive
 ‚îú‚îÄ‚îÄ db_ops.py           # Database operations (using jaydebeapi)
 ‚îú‚îÄ‚îÄ jira_ops.py         # Functions to fetch issues from JIRA API
 ‚îú‚îÄ‚îÄ templates/
 ‚îÇ      ‚îú‚îÄ‚îÄ list_jira.html         # HTML template to list issues with comments
 ‚îÇ      ‚îî‚îÄ‚îÄ interactive_jira.html  # HTML template for interactive view of one issue
 ‚îú‚îÄ‚îÄ requirements.txt

Below are the complete code listings for each component.

1. routes.py

This file defines three endpoints:
	‚Ä¢	/sync (POST): Calls the JIRA API and then updates/inserts/resolves issues in the DB.
	‚Ä¢	/list_jira (GET): Retrieves all issues (with comments) from the DB and renders them in a list HTML page.
	‚Ä¢	/interactive_jira (GET): Renders an interactive HTML page for a specific issue (using a query parameter for jira_number).

# routes.py
from flask import Flask, request, jsonify, render_template
from db_ops import sync_issues, get_all_issues, get_issue_details
from jira_ops import fetch_jira_issues
import json
import logging

app = Flask(__name__)
logging.basicConfig(level=logging.INFO)

@app.route('/sync', methods=['POST'])
def sync_service():
    """
    Sync service:
      - Fetches JIRA issues from the API.
      - Inserts new issues or updates existing ones (if comments changed) in the DB.
      - Marks issues as "Resolved" if they no longer appear in the JIRA filter.
      - Returns a JSON response with lists of inserted, updated, and resolved issues.
    """
    filter_id = request.json.get("filter_id", "12345")  # You can pass filter_id in POST data
    try:
        # Fetch issues from JIRA API
        jira_issues = fetch_jira_issues(filter_id)
        # Sync these issues into the database
        result = sync_issues(jira_issues)
        return jsonify(result), 200
    except Exception as e:
        logging.error(f"Sync service error: {str(e)}")
        return jsonify({"error": str(e)}), 500

@app.route('/list_jira', methods=['GET'])
def list_jira():
    """
    List service:
      - Retrieves all issues with their comments from the DB.
      - Renders them using list_jira.html.
    """
    try:
        issues = get_all_issues()  # Returns a list of issues with comments
        return render_template("list_jira.html", issues=issues)
    except Exception as e:
        logging.error(f"Error listing issues: {str(e)}")
        return jsonify({"error": str(e)}), 500

@app.route('/interactive_jira', methods=['GET'])
def interactive_jira():
    """
    Interactive service:
      - Renders an HTML page for a specific JIRA issue.
      - Expects a query parameter: jira_number.
      - The page displays issue details and its comments.
    """
    jira_number = request.args.get("jira_number")
    if not jira_number:
        return jsonify({"error": "jira_number parameter is required"}), 400

    try:
        issue = get_issue_details(jira_number)
        if not issue:
            return jsonify({"error": "Issue not found in DB"}), 404
        return render_template("interactive_jira.html", issue=issue)
    except Exception as e:
        logging.error(f"Error in interactive service: {str(e)}")
        return jsonify({"error": str(e)}), 500

if __name__ == '__main__':
    app.run(host="0.0.0.0", port=5000, debug=True)

2. jira_ops.py

This module defines a function to fetch issues from the JIRA API. It extracts the required fields including the list of comments and derives the job name (by removing the first character of the summary).

# jira_ops.py
import requests
import logging

JIRA_API_URL = "https://your-jira-instance.atlassian.net/rest/api/2/search"
JIRA_FILTER_ID = "12345"  # default filter if not provided
JIRA_API_TOKEN = "YOUR_JIRA_API_TOKEN"
HEADERS = {
    "Authorization": f"Bearer {JIRA_API_TOKEN}",
    "Content-Type": "application/json"
}

def fetch_jira_issues(filter_id):
    """
    Fetches JIRA issues using the JQL filter.
    Returns a list of dictionaries, each with:
       - jira_number
       - summary
       - status
       - comments (list of dicts: author, created, body)
       - job_name (derived from summary by removing the first character)
    """
    params = {
        "jql": f"filter={filter_id}",
        "fields": ["summary", "status", "comment"]
    }
    response = requests.get(JIRA_API_URL, headers=HEADERS, params=params)
    if response.status_code != 200:
        raise Exception(f"Error fetching JIRA issues: {response.text}")

    issues = response.json().get("issues", [])
    jira_data = []
    for issue in issues:
        jira_number = issue.get("key")
        summary = issue["fields"].get("summary", "")
        status = issue["fields"]["status"].get("name", "")
        # Extract comments with order preserved
        comment_list = []
        comment_field = issue["fields"].get("comment", {})
        if "comments" in comment_field:
            for comment in comment_field["comments"]:
                comment_list.append({
                    "author": comment["author"].get("displayName", "Unknown"),
                    "created": comment.get("created", ""),
                    "body": comment.get("body", "")
                })
        job_name = summary[1:] if summary else ""
        jira_data.append({
            "jira_number": jira_number,
            "summary": summary,
            "status": status,
            "comments": comment_list,
            "job_name": job_name
        })
    return jira_data

3. db_ops.py

This module handles all database operations using jaydebeapi. It updates the Issues table and the Issue_Comments table.
Assumptions:
	‚Ä¢	Issues table: columns (jira_number, summary, status, job_name)
	‚Ä¢	Issue_Comments table: columns (jira_number, comment_order, author, date_time, comment)

# db_ops.py
import jaydebeapi
import json
import logging
from config import DB_CONFIG  # Assume this file contains DB_CONFIG as shown below

JDBC_DRIVER = "oracle.jdbc.driver.OracleDriver"
JAR_PATH = "/app/utils/lib/ojdbc6.jar"

# Example DB_CONFIG in config.py:
# DB_CONFIG = {
#    "ENV1": {"url": "jdbc:oracle:thin:@//db1_host:1521/db1", "username": "user1", "password": "pass1"},
#    "ENV2": {"url": "jdbc:oracle:thin:@//db2_host:1521/db2", "username": "user2", "password": "pass2"}
# }

def get_db_connection(env):
    db_conf = DB_CONFIG.get(env)
    if not db_conf:
        raise Exception(f"No DB config for environment {env}")
    conn = jaydebeapi.connect(
        JDBC_DRIVER,
        db_conf["url"],
        [db_conf["username"], db_conf["password"]],
        JAR_PATH
    )
    return conn

def fetch_all_issues():
    """
    Fetch all issues from all DB environments.
    Returns a list of issue dictionaries including comments.
    """
    all_issues = []
    for env in DB_CONFIG.keys():
        conn = get_db_connection(env)
        cursor = conn.cursor()
        # Fetch issues from Issues table
        cursor.execute("SELECT jira_number, summary, status, job_name FROM Issues")
        issues = cursor.fetchall()
        for row in issues:
            jira_number, summary, status, job_name = row
            # Fetch comments for each issue
            cursor.execute("SELECT comment_order, author, date_time, comment FROM Issue_Comments WHERE jira_number = ? ORDER BY comment_order", (jira_number,))
            comments = [{"order": r[0], "author": r[1], "date_time": r[2], "comment": r[3]} for r in cursor.fetchall()]
            all_issues.append({
                "jira_number": jira_number,
                "summary": summary,
                "status": status,
                "job_name": job_name,
                "comments": comments,
                "env": env
            })
        cursor.close()
        conn.close()
    return all_issues

def get_db_issues_by_jira(jira_numbers, env):
    """
    Fetch issues from the specified DB environment for given jira_numbers.
    Returns a dict keyed by jira_number with stored comments (as list) and status.
    """
    conn = get_db_connection(env)
    cursor = conn.cursor()
    placeholders = ", ".join(["?"] * len(jira_numbers))
    query = f"SELECT jira_number, comments, status FROM Issues WHERE jira_number IN ({placeholders})"
    cursor.execute(query, jira_numbers)
    db_issues = {}
    for row in cursor.fetchall():
        jira_num = row[0]
        try:
            comments = json.loads(row[1])
        except Exception:
            comments = []
        db_issues[jira_num] = {"comments": comments, "status": row[2]}
    cursor.close()
    conn.close()
    return db_issues

def sync_issues(jira_data):
    """
    Sync JIRA issues into the database.
    For each issue in jira_data (fetched from JIRA API):
      - Determine DB environment based on job_name.
      - If issue (by jira_number) is not in DB, insert it.
      - If issue exists, compare comments; if different, update the Issue_Comments table.
    Also, for each DB environment, mark issues that are in the DB but not in the JIRA filter as "Resolved".
    Returns a JSON-compatible dict with keys: "inserted", "updated", "resolved" (each a list of {jira_number, job_name}).
    """
    sync_result = {"inserted": [], "updated": [], "resolved": []}

    # Organize issues by environment (based on job_name)
    issues_by_env = {}
    jira_numbers_all = set()
    for issue in jira_data:
        env = determine_db_env(issue["job_name"])
        if not env:
            continue
        issues_by_env.setdefault(env, []).append(issue)
        jira_numbers_all.add(issue["jira_number"])

    for env, issues in issues_by_env.items():
        # For each environment, get current issues from the DB by jira_number
        jira_nums = [issue["jira_number"] for issue in issues]
        db_issues = get_db_issues_by_jira(jira_nums, env)

        conn = get_db_connection(env)
        cursor = conn.cursor()

        for issue in issues:
            jira_number = issue["jira_number"]
            job_name = issue["job_name"]
            new_comments = issue["comments"]
            # Prepare new comments as JSON with order numbers
            comments_with_order = []
            for i, comment in enumerate(new_comments, start=1):
                # Each comment dict: author, created (date_time), body
                comments_with_order.append({
                    "order": i,
                    "author": comment["author"],
                    "date_time": comment["created"],
                    "comment": comment["body"]
                })
            new_comments_json = json.dumps(comments_with_order)

            # If issue exists in DB, compare comments (order sensitive)
            if jira_number in db_issues:
                stored_comments = db_issues[jira_number]["comments"]
                if stored_comments != comments_with_order:
                    # Delete old comments and insert new ones
                    cursor.execute("DELETE FROM Issue_Comments WHERE jira_number = ?", (jira_number,))
                    for comment in comments_with_order:
                        cursor.execute(
                            """INSERT INTO Issue_Comments (jira_number, comment_order, author, date_time, comment)
                               VALUES (?, ?, ?, ?, ?)""",
                            (jira_number, comment["order"], comment["author"], comment["date_time"], comment["comment"])
                        )
                    sync_result["updated"].append({"jira_number": jira_number, "job_name": job_name})
            else:
                # Insert new issue record in Issues table (if necessary)
                cursor.execute(
                    "INSERT INTO Issues (jira_number, summary, status, job_name) VALUES (?, ?, ?, ?)",
                    (jira_number, issue["summary"], issue["status"], job_name)
                )
                # Insert comments for the new issue
                for comment in comments_with_order:
                    cursor.execute(
                        """INSERT INTO Issue_Comments (jira_number, comment_order, author, date_time, comment)
                           VALUES (?, ?, ?, ?, ?)""",
                        (jira_number, comment["order"], comment["author"], comment["date_time"], comment["comment"])
                    )
                sync_result["inserted"].append({"jira_number": jira_number, "job_name": job_name})
        conn.commit()
        cursor.close()
        conn.close()

        # Mark missing issues as Resolved for this environment
        resolved = mark_resolved_issues_for_env(jira_numbers_all, env)
        sync_result["resolved"].extend(resolved)

    return sync_result

def mark_resolved_issues_for_env(jira_numbers_in_filter, env):
    """
    Marks issues as "Resolved" in the specified DB environment if they are not present in jira_numbers_in_filter
    and their status is not already 'Resolved'.
    Returns a list of issues (with jira_number and job_name) that were marked as resolved.
    """
    db_conf = DB_CONFIG.get(env)
    conn = get_db_connection(env)
    cursor = conn.cursor()

    # Fetch issues in DB that are not yet resolved
    cursor.execute("SELECT jira_number, job_name, status FROM Issues WHERE status <> 'Resolved'")
    db_issues = {row[0]: {"job_name": row[1], "status": row[2]} for row in cursor.fetchall()}
    resolved = []
    for jira_num, data in db_issues.items():
        if jira_num not in jira_numbers_in_filter:
            cursor.execute("UPDATE Issues SET status = 'Resolved' WHERE jira_number = ?", (jira_num,))
            resolved.append({"jira_number": jira_num, "job_name": data["job_name"]})
            print(f"Marked {jira_num} as Resolved in {env}")
    conn.commit()
    cursor.close()
    conn.close()
    return resolved

def determine_db_env(job_name):
    """
    Determines the database environment based on the job_name.
    For example, if job_name starts with "A", return "ENV1"; if "B", return "ENV2".
    Adjust this logic as needed.
    """
    if job_name.startswith("A"):
        return "ENV1"
    elif job_name.startswith("B"):
        return "ENV2"
    else:
        return None

def get_all_issues():
    """
    Fetch all issues (with comments) from all DB environments.
    Returns a list of issues with details.
    """
    all_issues = []
    for env in DB_CONFIG.keys():
        conn = get_db_connection(env)
        cursor = conn.cursor()
        cursor.execute("SELECT jira_number, summary, status, job_name FROM Issues")
        issues = cursor.fetchall()
        for row in issues:
            jira_number, summary, status, job_name = row
            cursor.execute("SELECT comment_order, author, date_time, comment FROM Issue_Comments WHERE jira_number = ? ORDER BY comment_order", (jira_number,))
            comments = [{"order": r[0], "author": r[1], "date_time": r[2], "comment": r[3]} for r in cursor.fetchall()]
            all_issues.append({
                "jira_number": jira_number,
                "summary": summary,
                "status": status,
                "job_name": job_name,
                "comments": comments,
                "env": env
            })
        cursor.close()
        conn.close()
    return all_issues

if __name__ == "__main__":
    filter_id = "12345"  # Example filter ID
    sync_result = sync_issues(filter_id)
    print(json.dumps(sync_result, indent=4))

4. HTML Templates

A. list_jira.html

This template displays all issues in a table with a column for comments that lists each comment (with order number, author, date, and comment text) in a legible format.

<!-- templates/list_jira.html -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JIRA Issues List</title>
    <style>
        table { border-collapse: collapse; width: 100%; }
        th, td { border: 1px solid #ccc; padding: 8px; text-align: left; }
        th { background-color: #f2f2f2; }
        .comment { margin-bottom: 5px; }
    </style>
</head>
<body>
    <h1>JIRA Issues List</h1>
    <table>
        <thead>
            <tr>
                <th>JIRA Number</th>
                <th>Summary</th>
                <th>Status</th>
                <th>Job Name</th>
                <th>Comments</th>
            </tr>
        </thead>
        <tbody>
            {% for issue in issues %}
            <tr>
                <td>{{ issue.jira_number }}</td>
                <td>{{ issue.summary }}</td>
                <td>{{ issue.status }}</td>
                <td>{{ issue.job_name }}</td>
                <td>
                    {% for comment in issue.comments %}
                        <div class="comment">
                            <strong>{{ comment.order }}. {{ comment.author }}</strong> ({{ comment.date_time }})<br>
                            {{ comment.comment }}
                        </div>
                    {% endfor %}
                </td>
            </tr>
            {% endfor %}
        </tbody>
    </table>
</body>
</html>

B. interactive_jira.html

This template displays details for a single issue in an interactive view. It shows the issue details and the comments in a table cell. You might add buttons to update comments dynamically (via JavaScript).

<!-- templates/interactive_jira.html -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive JIRA Issue</title>
    <style>
        .comment { margin-bottom: 8px; }
        table { border-collapse: collapse; width: 100%; }
        th, td { border: 1px solid #ccc; padding: 8px; text-align: left; }
        th { background-color: #f9f9f9; }
    </style>
    <script>
        async function updateComment() {
            const jiraNumber = document.getElementById("jira_number").value;
            const newComment = document.getElementById("new_comment").value;
            const response = await fetch("/update_comment", {
                method: "POST",
                headers: {"Content-Type": "application/json"},
                body: JSON.stringify({ jira_id: jiraNumber, comment: newComment })
            });
            const result = await response.json();
            alert(result.message || result.error);
            if (response.ok) {
                refreshComments(jiraNumber);
            }
        }

        async function refreshComments(jiraNumber) {
            const response = await fetch(`/get_issue_comments?jira_number=${jiraNumber}`);
            const data = await response.json();
            if (response.ok) {
                let commentsHtml = "";
                data.comments.forEach(function(c) {
                    commentsHtml += `<div class="comment"><strong>${c.order}. ${c.author}</strong> (${c.date_time})<br>${c.comment}</div>`;
                });
                document.getElementById("comments_container").innerHTML = commentsHtml;
            } else {
                alert("Failed to refresh comments");
            }
        }
    </script>
</head>
<body>
    <h1>Interactive JIRA Issue</h1>
    <input type="hidden" id="jira_number" value="{{ issue.jira_number }}">
    <p><strong>JIRA Number:</strong> {{ issue.jira_number }}</p>
    <p><strong>Summary:</strong> {{ issue.summary }}</p>
    <p><strong>Status:</strong> {{ issue.status }}</p>
    <p><strong>Job Name:</strong> {{ issue.job_name }}</p>
    <h2>Comments</h2>
    <div id="comments_container">
        {% for comment in issue.comments %}
            <div class="comment">
                <strong>{{ comment.order }}. {{ comment.author }}</strong> ({{ comment.date_time }})<br>
                {{ comment.comment }}
            </div>
        {% endfor %}
    </div>
    <h3>Update Comment</h3>
    <textarea id="new_comment" rows="4" cols="50" placeholder="Enter new comment"></textarea><br>
    <button onclick="updateComment()">Update Comment</button>
</body>
</html>

5. Final JSON Response (From Sync Service)

When the sync endpoint is called (POST /sync), the response is a JSON object structured as follows:

{
    "inserted": [
        {"jira_number": "JIRA-1001", "job_name": "A1"},
        {"jira_number": "JIRA-1002", "job_name": "B1"}
    ],
    "updated": [
        {"jira_number": "JIRA-1003", "job_name": "A2"}
    ],
    "resolved": [
        {"jira_number": "JIRA-1004", "job_name": "B2"}
    ]
}

This JSON is returned from the /sync endpoint in routes.py after processing all the issues.

Summary of Workflow
	1.	JIRA API Fetch (jira_ops.py):
	‚Ä¢	Fetch issues using a filter.
	‚Ä¢	Extract fields: jira_number, summary, status, comments.
	‚Ä¢	Derive job_name by removing the first character of summary.
	2.	Database Sync (db_ops.py):
	‚Ä¢	For each issue, based on job_name determine the DB environment.
	‚Ä¢	Use jira_number as unique key:
	‚Ä¢	If not found: Insert a new record into Issues and corresponding comments into Issue_Comments with an order number.
	‚Ä¢	If found and comments differ: Delete old comments for that jira_number and reinsert the updated list preserving the order.
	‚Ä¢	For issues in DB that are not in the JIRA filter and whose status is not ‚ÄúResolved,‚Äù update their status to ‚ÄúResolved.‚Äù
	3.	List Service (routes.py, /list_jira):
	‚Ä¢	Retrieves all issues from the DB (across environments) along with ordered comments.
	‚Ä¢	Renders a list using list_jira.html.
	4.	Interactive Service (routes.py, /interactive_jira):
	‚Ä¢	Renders a detailed view for a specific issue.
	‚Ä¢	Allows updating of comments via an AJAX call.
	‚Ä¢	Refreshes the comment section without a full page reload.
	5.	JSON Response:
	‚Ä¢	The sync service returns a structured JSON response listing inserted, updated, and resolved issues (each with jira_number and job_name).

This complete solution should fulfill the requirements for a sync service that inserts/updates JIRA issues (and their comments) into the appropriate Oracle database based on job_name, and displays them in list and interactive HTML templates. Let me know if you need further modifications or clarifications!