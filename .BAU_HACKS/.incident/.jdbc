
In the code snippet you provided, the filtering for prod_issues and quality_issues relies on the presence of a job_number equal to "P01" or "Q01". If there are no valid job_number values in the jira_issues, the result will be empty lists, which is the issue you’re observing.

To handle this, you can do the following:
	1.	Log or report issues with invalid job_number values.
	2.	Return or display these invalid issues in the HTML response for further analysis.

Updated sync_service Code

def sync_service():
    """
    Synchronizes JIRA issues with the database.
    Handles cases where job_number is invalid or missing.
    """
    try:
        jira_issues = fetch_jira_issues()  # Replace with the actual JIRA API call

        # Classify issues by job_number
        prod_issues = [issue for issue in jira_issues if issue.get("job_number") == "P01"]
        quality_issues = [issue for issue in jira_issues if issue.get("job_number") == "Q01"]

        # Collect issues with invalid or missing job_number
        invalid_issues = [
            issue for issue in jira_issues if issue.get("job_number") not in ["P01", "Q01"]
        ]

        # Handle invalid issues (Log or return to UI)
        if invalid_issues:
            print("Invalid Issues Found:")
            for issue in invalid_issues:
                print(f"JIRA Number: {issue['jira_number']}, Summary: {issue['summary']}")

        # Synchronize prod and quality issues
        if prod_issues:
            sync_to_db(prod_issues, "prod")
        else:
            print("No valid Prod issues found.")

        if quality_issues:
            sync_to_db(quality_issues, "quality")
        else:
            print("No valid Quality issues found.")

        return {
            "prod_issues": prod_issues,
            "quality_issues": quality_issues,
            "invalid_issues": invalid_issues,
        }

    except Exception as e:
        print(f"Error during synchronization: {str(e)}")
        return {"error": str(e)}

Key Updates
	1.	Handling Invalid Issues:
	•	Issues with missing or invalid job_number are filtered into the invalid_issues list.
	•	These can be logged or displayed in the HTML response.
	2.	Log or Notify:
	•	The function logs invalid issues for debugging and tracking.
	3.	Empty Prod/Quality Issues:
	•	When there are no valid prod_issues or quality_issues, a message is printed to indicate this.

HTML Response Update

You can include the invalid_issues in the HTML response, so they are visible to the user for manual review.

For example, in the HTML template:

<h2>Invalid Issues</h2>
{% if invalid_issues %}
    <table>
        <tr>
            <th>JIRA Number</th>
            <th>Summary</th>
            <th>Reason</th>
        </tr>
        {% for issue in invalid_issues %}
        <tr>
            <td>{{ issue.jira_number }}</td>
            <td>{{ issue.summary }}</td>
            <td>No valid job_number found (P01/Q01 missing)</td>
        </tr>
        {% endfor %}
    </table>
{% else %}
    <p>No invalid issues found.</p>
{% endif %}

Example Output

If the jira_issues contains the following data:

[
    {"jira_number": "JIRA-1", "summary": "Feature 1", "job_number": "P01"},
    {"jira_number": "JIRA-2", "summary": "Feature 2", "job_number": "Q01"},
    {"jira_number": "JIRA-3", "summary": "Invalid job number", "job_number": "X01"},
    {"jira_number": "JIRA-4", "summary": "Missing job number"}
]

	•	Prod Issues: ["JIRA-1"]
	•	Quality Issues: ["JIRA-2"]
	•	Invalid Issues:
	•	["JIRA-3", "JIRA-4"]

These results will be logged or displayed in the HTML.


=#=
Here is the organized implementation of the sync service with proper logic to handle update, insert, and delete operations in the database based on the JIRA API filter results. It ensures the synchronization is performed on the correct database (PROD or QUALITY) based on the Job Number extracted from the JIRA summary.

db_operations.py

This file contains the functions to manage the database synchronization logic.

import jaydebeapi

# Function to connect to the database
def connect_to_database(env):
    """
    Connects to the database based on the given environment.

    Args:
        env (str): The environment, either 'PROD' or 'QUALITY'.

    Returns:
        jaydebeapi.Connection: Database connection object.
    """
    db_configs = {
        "PROD": {"url": "jdbc:oracle:thin:@prod-db-url", "user": "prod_user", "password": "prod_password"},
        "QUALITY": {"url": "jdbc:oracle:thin:@quality-db-url", "user": "quality_user", "password": "quality_password"}
    }

    config = db_configs.get(env)
    if not config:
        raise ValueError(f"Invalid environment: {env}")

    return jaydebeapi.connect(
        "oracle.jdbc.OracleDriver",
        config["url"],
        [config["user"], config["password"]],
        "ojdbc8.jar"
    )


# Function to synchronize the database
def sync_issues_to_db(env, jira_issues):
    """
    Synchronizes the database with the given JIRA issues.
    
    Args:
        env (str): The environment to sync with, either 'PROD' or 'QUALITY'.
        jira_issues (list): List of JIRA issues returned by the API.
    """
    try:
        conn = connect_to_database(env)

        with conn.cursor() as cursor:
            # Step 1: If no issues from JIRA API, delete all rows
            if not jira_issues:
                cursor.execute("DELETE FROM jira_issues")
                conn.commit()
                print(f"Deleted all rows from the {env} database as no JIRA issues were returned.")
                return

            # Step 2: Fetch all existing JIRA numbers from the database
            cursor.execute("SELECT jira_number FROM jira_issues")
            db_issues = {row[0] for row in cursor.fetchall()}

            # Step 3: Determine insert, update, and delete operations
            jira_numbers = {issue["jira_number"] for issue in jira_issues}

            issues_to_insert = [issue for issue in jira_issues if issue["jira_number"] not in db_issues]
            issues_to_update = [issue for issue in jira_issues if issue["jira_number"] in db_issues]
            issues_to_delete = db_issues - jira_numbers

            # Step 4: Perform insert operations
            for issue in issues_to_insert:
                cursor.execute("""
                    INSERT INTO jira_issues (jira_number, status, summary, job_number, criticity, description,
                                             creation_date, comments, first_comment, last_comment)
                    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                """, (
                    issue["jira_number"], issue["status"], issue["summary"], issue["job_number"],
                    issue["criticity"], issue["description"], issue["creation_date"],
                    issue["comments"], issue["first_comment"], issue["last_comment"]
                ))

            # Step 5: Perform update operations
            for issue in issues_to_update:
                cursor.execute("""
                    UPDATE jira_issues
                    SET status = ?, summary = ?, job_number = ?, criticity = ?, description = ?, 
                        creation_date = ?, comments = ?, first_comment = ?, last_comment = ?
                    WHERE jira_number = ?
                """, (
                    issue["status"], issue["summary"], issue["job_number"],
                    issue["criticity"], issue["description"], issue["creation_date"],
                    issue["comments"], issue["first_comment"], issue["last_comment"],
                    issue["jira_number"]
                ))

            # Step 6: Perform delete operations
            for jira_number in issues_to_delete:
                cursor.execute("DELETE FROM jira_issues WHERE jira_number = ?", (jira_number,))

            # Commit the changes
            conn.commit()

            print(f"Sync completed for {env} database. Inserted: {len(issues_to_insert)}, "
                  f"Updated: {len(issues_to_update)}, Deleted: {len(issues_to_delete)}")

    except Exception as e:
        print(f"Error syncing issues to the {env} database: {e}")
        raise

    finally:
        if conn:
            conn.close()

routes.py

This file defines the /sync route to handle synchronization.

from flask import Blueprint, request, jsonify
from db_operations import sync_issues_to_db

routes = Blueprint("routes", __name__)

# Mock function to fetch JIRA issues (replace with actual API call logic)
def fetch_jira_issues():
    return [
        {
            "jira_number": "JIRA-001",
            "status": "Open",
            "summary": "Fix bug P01",
            "job_number": "P01",
            "criticity": "High",
            "description": "Description 1",
            "creation_date": "2025-01-01",
            "comments": "Comment 1",
            "first_comment": "First comment",
            "last_comment": "Last comment"
        },
        {
            "jira_number": "JIRA-002",
            "status": "In Progress",
            "summary": "Feature Q01",
            "job_number": "Q01",
            "criticity": "Medium",
            "description": "Description 2",
            "creation_date": "2025-01-02",
            "comments": "Comment 2",
            "first_comment": "First comment",
            "last_comment": "Last comment"
        }
    ]


@routes.route("/sync", methods=["POST"])
def sync_service():
    """
    Synchronizes JIRA issues with the database.
    """
    try:
        jira_issues = fetch_jira_issues()  # Replace with the actual JIRA API call
        prod_issues = [issue for issue in jira_issues if issue["job_number"] == "P01"]
        quality_issues = [issue for issue in jira_issues if issue["job_number"] == "Q01"]

        if prod_issues:
            sync_issues_to_db("PROD", prod_issues)

        if quality_issues:
            sync_issues_to_db("QUALITY", quality_issues)

        return jsonify({"message": "Synchronization completed"}), 200

    except Exception as e:
        return jsonify({"error": str(e)}), 500

Key Features
	1.	Dynamic Environment Selection:
	•	Synchronization happens to PROD or QUALITY based on the job_number in the JIRA summary.
	2.	CRUD Operations:
	•	Insert new issues from the JIRA API.
	•	Update existing issues.
	•	Delete issues that are no longer in the JIRA API results.
	3.	Empty JIRA API Results:
	•	Deletes all rows from the database when no JIRA issues are returned.
	4.	Error Handling:
	•	Proper error handling ensures stability and logs errors for debugging.

Usage
	•	Deploy the app using Kubernetes or locally.
	•	Use /sync endpoint to trigger synchronization.

Example Request:

curl -X POST http://localhost:5000/sync

=#=
Here’s the implementation of the sync_issues function in db_operations.py that handles insert, update, and delete operations in the database based on the issues fetched from the JIRA API.

This implementation ensures:
	•	Insertion of new issues.
	•	Updating existing issues based on the JIRA number.
	•	Deletion of issues in the database that are no longer present in the JIRA API response.
	•	Connects to the correct environment (PROD or QUALITY) based on the job_number in the issue’s summary.

sync_issues in db_operations.py

import jaydebeapi
import logging

class DatabaseOperations:
    def __init__(self, db_config):
        """
        Initialize the DatabaseOperations with DB config.
        """
        self.db_config = db_config

    def get_connection(self, environment):
        """
        Establish and return a JDBC connection to the database based on the environment.
        """
        if environment == "PROD":
            conn_details = self.db_config["PROD"]
        elif environment == "QUALITY":
            conn_details = self.db_config["QUALITY"]
        else:
            raise ValueError("Invalid environment specified")

        connection = jaydebeapi.connect(
            conn_details["driver"],
            conn_details["url"],
            [conn_details["user"], conn_details["password"]],
            conn_details["jar_path"],
        )
        return connection

    def sync_issues(self, issues, environment):
        """
        Synchronize issues to the database: insert new, update existing, and delete stale records.

        :param issues: List of issues fetched from the JIRA API.
        :param environment: The target environment ("PROD" or "QUALITY").
        :return: A dictionary with inserted, updated, and deleted JIRA numbers.
        """
        try:
            connection = self.get_connection(environment)
            cursor = connection.cursor()

            # Fetch existing issues from the database
            cursor.execute("SELECT jira_number FROM issues")
            db_jira_numbers = {row[0] for row in cursor.fetchall()}

            # Prepare sets for comparison
            api_jira_numbers = {issue["jira_number"] for issue in issues}
            issues_to_insert = [issue for issue in issues if issue["jira_number"] not in db_jira_numbers]
            issues_to_update = [issue for issue in issues if issue["jira_number"] in db_jira_numbers]
            issues_to_delete = db_jira_numbers - api_jira_numbers

            inserted = []
            updated = []
            deleted = []

            # Insert new issues
            for issue in issues_to_insert:
                query = """
                    INSERT INTO issues (jira_number, status, summary, job_number, criticity, description, creation_date, comments, first_comment, last_comment, update_comment, update_status)
                    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, '', '')
                """
                cursor.execute(
                    query,
                    (
                        issue["jira_number"],
                        issue["status"],
                        issue["summary"],
                        issue["job_number"],
                        issue["criticity"],
                        issue["description"],
                        issue["creation_date"],
                        issue["comments"],
                        issue["first_comment"],
                        issue["last_comment"],
                    ),
                )
                inserted.append(issue["jira_number"])

            # Update existing issues
            for issue in issues_to_update:
                query = """
                    UPDATE issues
                    SET status = ?, summary = ?, job_number = ?, criticity = ?, description = ?, creation_date = ?, comments = ?, first_comment = ?, last_comment = ?
                    WHERE jira_number = ?
                """
                cursor.execute(
                    query,
                    (
                        issue["status"],
                        issue["summary"],
                        issue["job_number"],
                        issue["criticity"],
                        issue["description"],
                        issue["creation_date"],
                        issue["comments"],
                        issue["first_comment"],
                        issue["last_comment"],
                        issue["jira_number"],
                    ),
                )
                updated.append(issue["jira_number"])

            # Delete stale issues
            for jira_number in issues_to_delete:
                query = "DELETE FROM issues WHERE jira_number = ?"
                cursor.execute(query, (jira_number,))
                deleted.append(jira_number)

            # Commit the transaction
            connection.commit()

            logging.info(f"Sync completed for {environment}: {len(inserted)} inserted, {len(updated)} updated, {len(deleted)} deleted.")
            return {
                "inserted_jira_numbers": inserted,
                "updated_jira_numbers": updated,
                "deleted_jira_numbers": deleted,
            }

        except Exception as e:
            logging.error(f"Error during sync operation: {e}")
            raise

        finally:
            if 'cursor' in locals():
                cursor.close()
            if 'connection' in locals():
                connection.close()

Explanation of the Code:

Database Connection:
	•	get_connection establishes a JDBC connection using jaydebeapi for the specified environment (PROD or QUALITY).

Fetch Existing Issues:
	•	The query "SELECT jira_number FROM issues" retrieves all existing JIRA numbers from the database.

Comparison Logic:
	•	issues_to_insert: Issues in the API response but not in the database.
	•	issues_to_update: Issues in both the API response and the database.
	•	issues_to_delete: Issues in the database but not in the API response.

Insert, Update, Delete:
	•	Insert:
	•	For new issues, an INSERT query is executed with all issue details.
	•	Update:
	•	For existing issues, an UPDATE query updates the details for matching JIRA numbers.
	•	Delete:
	•	For stale issues, a DELETE query removes them from the database.

Transaction Handling:
	•	connection.commit() ensures that all changes are committed to the database.

Error Handling:
	•	Logs errors and raises exceptions if any part of the sync process fails.

Return Value:
	•	Returns a dictionary with lists of JIRA numbers for inserted, updated, and deleted issues, which can be used to generate the HTML report.

Sample Output:

If the following operations occurred:
	•	Inserted: JIRA-001, JIRA-003
	•	Updated: JIRA-002
	•	Deleted: JIRA-004

The returned dictionary would be:

{
    "inserted_jira_numbers": ["JIRA-001", "JIRA-003"],
    "updated_jira_numbers": ["JIRA-002"],
    "deleted_jira_numbers": ["JIRA-004"],
}

This result can be passed to the HTML generation logic to create the sync report.

Let me know if further refinements are needed!


=#=#=
To include the JIRA numbers in the HTML report for each operation (Insert, Update, Delete), we can enhance the HTML template to display the specific JIRA numbers in separate sections.

Here’s the updated implementation:

Updated /sync Service in routes.py

from flask import Flask, request, render_template_string
from db_operations import DatabaseOperations
from jira_service import get_issues_from_jira

app = Flask(__name__)
db_operations = DatabaseOperations()

@app.route("/sync", methods=["POST"])
def sync_issues():
    try:
        # Get JIRA issues from API
        jira_filter_id = request.json.get("filter_id")
        issues = get_issues_from_jira(jira_filter_id)

        # Group issues by environment based on job number in summary
        prod_issues = [issue for issue in issues if "P01" in issue["job_number"]]
        quality_issues = [issue for issue in issues if "Q01" in issue["job_number"]]

        # Sync issues with the respective environments
        prod_result = db_operations.sync_issues(prod_issues, "PROD")
        quality_result = db_operations.sync_issues(quality_issues, "QUALITY")

        # Generate HTML report
        html_report = generate_html_report(prod_result, quality_result)

        # Return HTML response
        return render_template_string(html_report)

    except Exception as e:
        return f"<html><body><h1>Error: {str(e)}</h1></body></html>", 500


def generate_html_report(prod_result, quality_result):
    """Generate an HTML report for the sync results."""
    html_template = """
    <!DOCTYPE html>
    <html>
    <head>
        <title>Sync Report</title>
        <style>
            table {{
                width: 100%;
                border-collapse: collapse;
                margin: 20px 0;
                font-size: 16px;
                text-align: left;
            }}
            table th, table td {{
                border: 1px solid #dddddd;
                padding: 8px;
            }}
            table th {{
                background-color: #f2f2f2;
            }}
            .section {{
                margin: 20px 0;
            }}
        </style>
    </head>
    <body>
        <h1>JIRA Sync Report</h1>
        
        <div class="section">
            <h2>Prod Environment</h2>
            <h3>Inserted JIRA Numbers</h3>
            <ul>
                {% for jira in prod_result['inserted_jira_numbers'] %}
                    <li><a href="https://jira.example.com/browse/{{ jira }}">{{ jira }}</a></li>
                {% endfor %}
            </ul>

            <h3>Updated JIRA Numbers</h3>
            <ul>
                {% for jira in prod_result['updated_jira_numbers'] %}
                    <li><a href="https://jira.example.com/browse/{{ jira }}">{{ jira }}</a></li>
                {% endfor %}
            </ul>

            <h3>Deleted JIRA Numbers</h3>
            <ul>
                {% for jira in prod_result['deleted_jira_numbers'] %}
                    <li><a href="https://jira.example.com/browse/{{ jira }}">{{ jira }}</a></li>
                {% endfor %}
            </ul>
        </div>

        <div class="section">
            <h2>Quality Environment</h2>
            <h3>Inserted JIRA Numbers</h3>
            <ul>
                {% for jira in quality_result['inserted_jira_numbers'] %}
                    <li><a href="https://jira.example.com/browse/{{ jira }}">{{ jira }}</a></li>
                {% endfor %}
            </ul>

            <h3>Updated JIRA Numbers</h3>
            <ul>
                {% for jira in quality_result['updated_jira_numbers'] %}
                    <li><a href="https://jira.example.com/browse/{{ jira }}">{{ jira }}</a></li>
                {% endfor %}
            </ul>

            <h3>Deleted JIRA Numbers</h3>
            <ul>
                {% for jira in quality_result['deleted_jira_numbers'] %}
                    <li><a href="https://jira.example.com/browse/{{ jira }}">{{ jira }}</a></li>
                {% endfor %}
            </ul>
        </div>
    </body>
    </html>
    """
    return render_template_string(
        html_template,
        prod_result=prod_result,
        quality_result=quality_result,
    )

Changes to sync_issues in db_operations.py

Update sync_issues to return the JIRA numbers involved in each operation:

class DatabaseOperations:
    def sync_issues(self, issues, environment):
        inserted = []
        updated = []
        deleted = []

        # Perform sync operations
        for issue in issues:
            # Example logic for insert/update/delete
            if self.issue_needs_insertion(issue, environment):
                self.insert_issue(issue, environment)
                inserted.append(issue["jira_number"])
            elif self.issue_needs_update(issue, environment):
                self.update_issue(issue, environment)
                updated.append(issue["jira_number"])
            else:
                if self.issue_needs_deletion(issue, environment):
                    self.delete_issue(issue, environment)
                    deleted.append(issue["jira_number"])

        return {
            "inserted_jira_numbers": inserted,
            "updated_jira_numbers": updated,
            "deleted_jira_numbers": deleted,
        }

    def issue_needs_insertion(self, issue, environment):
        # Custom logic to check if the issue needs to be inserted
        pass

    def issue_needs_update(self, issue, environment):
        # Custom logic to check if the issue needs to be updated
        pass

    def issue_needs_deletion(self, issue, environment):
        # Custom logic to check if the issue needs to be deleted
        pass

    def insert_issue(self, issue, environment):
        # Logic to insert issue into the database
        pass

    def update_issue(self, issue, environment):
        # Logic to update issue in the database
        pass

    def delete_issue(self, issue, environment):
        # Logic to delete issue from the database
        pass

HTML Enhancements:
	1.	Lists by Operation:
	•	The Inserted, Updated, and Deleted sections are separated.
	•	Each JIRA number is hyperlinked to the corresponding JIRA issue page.
	2.	Dynamic Content:
	•	Populates each operation section with the respective JIRA numbers from the sync results.

Example Output:

Prod Environment

Inserted JIRA Numbers:
	•	JIRA-123
	•	JIRA-124

Updated JIRA Numbers:
	•	JIRA-125

Deleted JIRA Numbers:
	•	JIRA-126

Let me know if additional modifications are needed!

Below is the complete implementation of a database syncing service that uses jaydebeapi to connect to an Oracle database via JDBC. It handles insert, update, and delete operations in the database based on data fetched from the JIRA API filter and the Job_Number in the summary to decide the environment (Prod or Quality).

db_operations.py

This module handles database operations: connecting to the correct environment (Prod or Quality) and performing insert, update, and delete actions.

import jaydebeapi
import os
from typing import List, Dict

class DatabaseOperations:
    def __init__(self):
        self.jdbc_driver = os.getenv("JDBC_DRIVER_PATH", "/path/to/ojdbc8.jar")
        self.prod_db_url = os.getenv("PROD_DB_URL", "jdbc:oracle:thin:@prod_host:1521/prod_service")
        self.quality_db_url = os.getenv("QUALITY_DB_URL", "jdbc:oracle:thin:@quality_host:1521/quality_service")
        self.username = os.getenv("DB_USERNAME", "db_user")
        self.password = os.getenv("DB_PASSWORD", "db_password")
        self.driver_name = "oracle.jdbc.OracleDriver"

    def get_connection(self, env: str):
        """Get a database connection for the specified environment."""
        db_url = self.prod_db_url if env == "PROD" else self.quality_db_url
        return jaydebeapi.connect(self.driver_name, db_url, [self.username, self.password], self.jdbc_driver)

    def sync_issues(self, issues: List[Dict], env: str):
        """Sync issues with the database (insert, update, delete)."""
        connection = self.get_connection(env)
        cursor = connection.cursor()

        try:
            # Get the list of existing JIRA IDs in the database
            cursor.execute("SELECT jira_number FROM issues")
            existing_jiras = {row[0] for row in cursor.fetchall()}

            # Prepare for syncing
            jira_ids_in_filter = {issue["jira_number"] for issue in issues}
            issues_to_insert = [issue for issue in issues if issue["jira_number"] not in existing_jiras]
            issues_to_update = [issue for issue in issues if issue["jira_number"] in existing_jiras]
            issues_to_delete = existing_jiras - jira_ids_in_filter

            # Insert new issues
            for issue in issues_to_insert:
                cursor.execute(
                    """
                    INSERT INTO issues (jira_number, status, summary, job_number, criticity, description,
                                        creation_date, comments, first_comment, last_comment)
                    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                    """,
                    [
                        issue["jira_number"], issue["status"], issue["summary"], issue["job_number"],
                        issue["criticity"], issue["description"], issue["creation_date"],
                        issue["comments"], issue["first_comment"], issue["last_comment"]
                    ]
                )

            # Update existing issues
            for issue in issues_to_update:
                cursor.execute(
                    """
                    UPDATE issues
                    SET status = ?, summary = ?, job_number = ?, criticity = ?, description = ?, 
                        creation_date = ?, comments = ?, first_comment = ?, last_comment = ?
                    WHERE jira_number = ?
                    """,
                    [
                        issue["status"], issue["summary"], issue["job_number"], issue["criticity"],
                        issue["description"], issue["creation_date"], issue["comments"],
                        issue["first_comment"], issue["last_comment"], issue["jira_number"]
                    ]
                )

            # Delete issues not in the current filter
            for jira_number in issues_to_delete:
                cursor.execute("DELETE FROM issues WHERE jira_number = ?", [jira_number])

            connection.commit()

            return {
                "inserted": len(issues_to_insert),
                "updated": len(issues_to_update),
                "deleted": len(issues_to_delete)
            }

        except Exception as e:
            connection.rollback()
            raise RuntimeError(f"Error during database sync: {e}")

        finally:
            cursor.close()
            connection.close()

routes.py

This module defines the /sync route, fetching issues from the JIRA API and syncing them with the database.

from flask import Flask, request, jsonify
from db_operations import DatabaseOperations
from jira_service import get_issues_from_jira

app = Flask(__name__)
db_operations = DatabaseOperations()

@app.route("/sync", methods=["POST"])
def sync_issues():
    try:
        # Get JIRA issues from API
        jira_filter_id = request.json.get("filter_id")
        issues = get_issues_from_jira(jira_filter_id)

        # Group issues by environment based on job number in summary
        prod_issues = [issue for issue in issues if "P01" in issue["job_number"]]
        quality_issues = [issue for issue in issues if "Q01" in issue["job_number"]]

        # Sync issues with the respective environments
        prod_result = db_operations.sync_issues(prod_issues, "PROD")
        quality_result = db_operations.sync_issues(quality_issues, "QUALITY")

        # Return results
        return jsonify({
            "message": "Sync completed successfully",
            "prod": prod_result,
            "quality": quality_result
        })

    except Exception as e:
        return jsonify({"error": str(e)}), 500

settings.py

This module loads environment variables.

from dotenv import load_dotenv
import os

# Load environment variables from .env file
load_dotenv()

# Database settings
JDBC_DRIVER_PATH = os.getenv("JDBC_DRIVER_PATH", "/path/to/ojdbc8.jar")
PROD_DB_URL = os.getenv("PROD_DB_URL", "jdbc:oracle:thin:@prod_host:1521/prod_service")
QUALITY_DB_URL = os.getenv("QUALITY_DB_URL", "jdbc:oracle:thin:@quality_host:1521/quality_service")
DB_USERNAME = os.getenv("DB_USERNAME", "db_user")
DB_PASSWORD = os.getenv("DB_PASSWORD", "db_password")

# JIRA API settings
JIRA_API_TOKEN = os.getenv("JIRA_API_TOKEN", "your_jira_api_token")
JIRA_BASE_URL = os.getenv("JIRA_BASE_URL", "https://your-jira-instance.atlassian.net")

Key Features:
	1.	Environment Selection:
	•	JIRA issues are grouped based on the job_number in the summary (P01 → PROD, Q01 → QUALITY).
	2.	Sync Logic:
	•	Insert new issues that are not in the database.
	•	Update existing issues if they match the JIRA number.
	•	Delete issues from the database that are not in the current JIRA filter.
	3.	Return Results:
	•	The /sync service returns a summary of inserted, updated, and deleted issues for each environment.

Deployment:

To deploy this service:
	1.	Install dependencies:

pip install flask jaydebeapi python-dotenv


	2.	Set up your .env file:

JDBC_DRIVER_PATH=/path/to/ojdbc8.jar
PROD_DB_URL=jdbc:oracle:thin:@prod_host:1521/prod_service
QUALITY_DB_URL=jdbc:oracle:thin:@quality_host:1521/quality_service
DB_USERNAME=db_user
DB_PASSWORD=db_password
JIRA_API_TOKEN=your_jira_api_token
JIRA_BASE_URL=https://your-jira-instance.atlassian.net


	3.	Run the Flask app:

flask run



This implementation provides a robust syncing solution for Oracle databases via thin mode using jaydebeapi. Let me know if further customization is needed!
#=#=

Below are the implementations for db_operations.py, routes.py, and settings.py to handle the /sync service along with proper environment variable management.

db_operations.py

This module contains the database interaction logic.

import jaydebeapi
from contextlib import contextmanager


class DatabaseManager:
    def __init__(self, jdbc_url, driver_class, jar_path, username, password):
        self.jdbc_url = jdbc_url
        self.driver_class = driver_class
        self.jar_path = jar_path
        self.username = username
        self.password = password

    @contextmanager
    def connect(self):
        """Context manager to establish and close the database connection."""
        conn = None
        try:
            conn = jaydebeapi.connect(
                self.driver_class,
                self.jdbc_url,
                [self.username, self.password],
                self.jar_path,
            )
            yield conn
        finally:
            if conn:
                conn.close()

    def sync_issues(self, issues, environment):
        """
        Synchronize issues into the database.
        Insert or update if JIRA exists, delete if missing from the response.
        """
        with self.connect() as conn:
            cursor = conn.cursor()

            # Insert or Update issues
            for issue in issues:
                cursor.execute(
                    """
                    MERGE INTO issues_table i
                    USING (SELECT ? AS jira_number FROM dual) src
                    ON (i.jira_number = src.jira_number)
                    WHEN MATCHED THEN UPDATE SET
                        status = ?,
                        summary = ?,
                        job_number = ?,
                        criticity = ?,
                        description = ?,
                        creation_date = ?,
                        comments = ?,
                        first_comment = ?,
                        last_comment = ?,
                        environment = ?
                    WHEN NOT MATCHED THEN INSERT (
                        jira_number, status, summary, job_number, criticity, description,
                        creation_date, comments, first_comment, last_comment, environment
                    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                    """,
                    (
                        # For MATCHED (Update)
                        issue["jira_number"],
                        issue["status"],
                        issue["summary"],
                        issue["job_number"],
                        issue["criticity"],
                        issue["description"],
                        issue["creation_date"],
                        "\n".join(issue["comments"]),
                        issue["first_comment"],
                        issue["last_comment"],
                        environment,
                        # For NOT MATCHED (Insert)
                        issue["jira_number"],
                        issue["status"],
                        issue["summary"],
                        issue["job_number"],
                        issue["criticity"],
                        issue["description"],
                        issue["creation_date"],
                        "\n".join(issue["comments"]),
                        issue["first_comment"],
                        issue["last_comment"],
                        environment,
                    ),
                )

            # Delete issues not in the current JIRA list
            jira_numbers = [issue["jira_number"] for issue in issues]
            cursor.execute(
                "DELETE FROM issues_table WHERE environment = ? AND jira_number NOT IN ({})".format(
                    ",".join(["?"] * len(jira_numbers))
                ),
                [environment] + jira_numbers,
            )
            conn.commit()

routes.py

This module defines the Flask routes and connects the /sync service.

from flask import Flask, request, jsonify
from .db_operations import DatabaseManager
from .jira_api import JiraAPI
from .settings import Config
import re

app = Flask(__name__)
app.config.from_object(Config)


def extract_job_number(summary):
    """Extract job number (P01/Q01/etc.) from the summary using regex."""
    match = re.search(r"(P\d{2}|Q\d{2})", summary)
    return match.group(0) if match else None


@app.route("/sync", methods=["POST"])
def sync_issues_db():
    """
    Synchronize JIRA issues with the database.
    """
    try:
        # Load JIRA filter ID from request
        data = request.get_json()
        filter_id = data.get("filter_id")
        if not filter_id:
            return jsonify({"error": "filter_id is required"}), 400

        # Fetch JIRA issues
        jira_api = JiraAPI(app.config["JIRA_BASE_URL"], app.config["JIRA_TOKEN"])
        jira_issues = jira_api.get_issues(filter_id)

        # Categorize issues by environment
        prod_issues = []
        quality_issues = []
        for issue in jira_issues:
            job_number = extract_job_number(issue["fields"]["summary"])
            if job_number:
                issue_data = {
                    "jira_number": issue["key"],
                    "status": issue["fields"]["status"]["name"],
                    "summary": issue["fields"]["summary"],
                    "job_number": job_number,
                    "criticity": issue["fields"]["priority"]["name"],
                    "description": issue["fields"]["description"],
                    "creation_date": issue["fields"]["created"],
                    "comments": [c["body"] for c in issue["fields"]["comment"]["comments"]],
                    "first_comment": (
                        issue["fields"]["comment"]["comments"][0]["body"]
                        if issue["fields"]["comment"]["comments"]
                        else None
                    ),
                    "last_comment": (
                        issue["fields"]["comment"]["comments"][-1]["body"]
                        if issue["fields"]["comment"]["comments"]
                        else None
                    ),
                }
                if job_number.startswith("P"):
                    prod_issues.append(issue_data)
                elif job_number.startswith("Q"):
                    quality_issues.append(issue_data)

        # Sync issues with production database
        prod_db = DatabaseManager(
            app.config["PROD_JDBC_URL"],
            app.config["JDBC_DRIVER"],
            app.config["JDBC_JAR_PATH"],
            app.config["PROD_DB_USERNAME"],
            app.config["PROD_DB_PASSWORD"],
        )
        prod_db.sync_issues(prod_issues, "PROD")

        # Sync issues with quality database
        quality_db = DatabaseManager(
            app.config["QUALITY_JDBC_URL"],
            app.config["JDBC_DRIVER"],
            app.config["JDBC_JAR_PATH"],
            app.config["QUALITY_DB_USERNAME"],
            app.config["QUALITY_DB_PASSWORD"],
        )
        quality_db.sync_issues(quality_issues, "QUALITY")

        return jsonify({"status": "success", "message": "Sync completed"}), 200

    except Exception as e:
        return jsonify({"error": str(e)}), 500

settings.py

This module manages environment variables for database and JIRA settings.

import os
from dotenv import load_dotenv

# Load environment variables from .env
load_dotenv()


class Config:
    # JIRA Configuration
    JIRA_BASE_URL = os.getenv("JIRA_BASE_URL")
    JIRA_TOKEN = os.getenv("JIRA_TOKEN")

    # Database Configuration
    JDBC_DRIVER = os.getenv("JDBC_DRIVER", "oracle.jdbc.OracleDriver")
    JDBC_JAR_PATH = os.getenv("JDBC_JAR_PATH", "/path/to/ojdbc8.jar")

    # Production Database
    PROD_JDBC_URL = os.getenv("PROD_JDBC_URL")
    PROD_DB_USERNAME = os.getenv("PROD_DB_USERNAME")
    PROD_DB_PASSWORD = os.getenv("PROD_DB_PASSWORD")

    # Quality Database
    QUALITY_JDBC_URL = os.getenv("QUALITY_JDBC_URL")
    QUALITY_DB_USERNAME = os.getenv("QUALITY_DB_USERNAME")
    QUALITY_DB_PASSWORD = os.getenv("QUALITY_DB_PASSWORD")

.env

Example of environment variables file:

JIRA_BASE_URL=https://your-jira-instance.atlassian.net
JIRA_TOKEN=your_jira_bearer_token

JDBC_DRIVER=oracle.jdbc.OracleDriver
JDBC_JAR_PATH=/path/to/ojdbc8.jar

PROD_JDBC_URL=jdbc:oracle:thin:@prod-db-host:1521:prod_service
PROD_DB_USERNAME=prod_user
PROD_DB_PASSWORD=prod_password

QUALITY_JDBC_URL=jdbc:oracle:thin:@quality-db-host:1521:quality_service
QUALITY_DB_USERNAME=quality_user
QUALITY_DB_PASSWORD=quality_password

Usage
	1.	Install dependencies:

pip install Flask python-dotenv JayDeBeApi


	2.	Start the Flask server:

flask run


	3.	Test the /sync endpoint by sending a POST request with a filter_id.

Let me know if further details or adjustments are needed!