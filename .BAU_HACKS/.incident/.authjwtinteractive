
Yes, environment variables reset when the container restarts. Since you want the interactive user token to persist forever, you need an external storage mechanism.

Solution Options:
	1.	Store Tokens in a Kubernetes Secret or ConfigMap (Best for Kubernetes)
	2.	Use a Redis Store (Best for distributed systems)
	3.	Store in a Database (PostgreSQL/MySQL) (For long-term storage)

⸻

Option 1: Persist in a Kubernetes Secret

Use a Kubernetes Secret to store USER_TOKENS, ensuring it persists even after a restart.

Step 1: Create a Kubernetes Secret

apiVersion: v1
kind: Secret
metadata:
  name: user-tokens-secret
type: Opaque
data:
  USER_TOKENS: e30=  # "{}" (empty JSON) base64 encoded

Step 2: Mount Secret in Your Flask Deployment

apiVersion: apps/v1
kind: Deployment
metadata:
  name: interactive-service
spec:
  replicas: 1
  template:
    spec:
      containers:
        - name: interactive-service
          image: your-image:latest
          env:
            - name: USER_TOKENS
              valueFrom:
                secretKeyRef:
                  name: user-tokens-secret
                  key: USER_TOKENS

Step 3: Update Secret in Flask Code

Modify the Flask app to read and write from this secret:

def load_user_tokens():
    """Load user tokens from Kubernetes Secret (if available)."""
    user_tokens_json = os.getenv("USER_TOKENS", "{}")
    return json.loads(base64.b64decode(user_tokens_json).decode()) if user_tokens_json else {}

def save_user_tokens(tokens):
    """Update the Kubernetes Secret dynamically."""
    encoded_tokens = base64.b64encode(json.dumps(tokens).encode()).decode()
    os.system(f'kubectl patch secret user-tokens-secret --type="merge" -p \'{{"data": {{"USER_TOKENS": "{encoded_tokens}"}}}}\'')

USER_TOKENS = load_user_tokens()

	•	This ensures that tokens persist in Kubernetes Secrets, even after restarts.

⸻

Option 2: Use Redis for Persistent Storage

Instead of using environment variables, store user tokens in Redis.

Install Redis in Kubernetes

helm install redis bitnami/redis --set auth.enabled=false

This deploys a Redis instance without authentication.

Update Flask Code to Use Redis

import redis

redis_client = redis.StrictRedis(host="redis", port=6379, decode_responses=True)

def load_user_tokens():
    """Load user tokens from Redis."""
    user_tokens_json = redis_client.get("USER_TOKENS")
    return json.loads(user_tokens_json) if user_tokens_json else {}

def save_user_tokens(tokens):
    """Save user tokens in Redis."""
    redis_client.set("USER_TOKENS", json.dumps(tokens))

	•	Tokens are stored in Redis and persist across container restarts.

⸻

Option 3: Store Tokens in a Database

If you already have PostgreSQL/MySQL, store the tokens in a table.

Create a Table

CREATE TABLE user_tokens (
    username VARCHAR(255) PRIMARY KEY,
    token TEXT NOT NULL
);

Update Flask Code

import psycopg2

conn = psycopg2.connect("dbname=mydb user=myuser password=mypass host=mydb-host")
cursor = conn.cursor()

def load_user_tokens():
    """Load user tokens from PostgreSQL."""
    cursor.execute("SELECT username, token FROM user_tokens")
    return {row[0]: row[1] for row in cursor.fetchall()}

def save_user_tokens(tokens):
    """Save user tokens in PostgreSQL."""
    for user, token in tokens.items():
        cursor.execute(
            "INSERT INTO user_tokens (username, token) VALUES (%s, %s) ON CONFLICT (username) DO UPDATE SET token = EXCLUDED.token",
            (user, token),
        )
    conn.commit()

	•	Tokens persist across restarts in PostgreSQL.

⸻

Best Choice?

Storage	Persistence	Scalability	Ease of Use
Kubernetes Secret	✅ Yes (persists in cluster)	❌ Not scalable	✅ Easy
Redis	✅ Yes (persists if configured)	✅ Scales well	✅ Medium
PostgreSQL/MySQL	✅ Yes (persists)	✅ Scales well	❌ More setup

	•	Use Kubernetes Secret → If only needed inside Kubernetes.
	•	Use Redis → If you want speed and scalability.
	•	Use PostgreSQL/MySQL → If you already have a DB.

Do you want to go with Kubernetes Secret, Redis, or PostgreSQL?

=#
If you want to store the user-specific JWT secrets in an environment variable, here’s the best approach:

Solution: Store User Tokens in an Environment Variable

Since environment variables do not persist across container restarts, you need a way to reload the stored user tokens on startup. We can achieve this by:
	1.	Storing the user-specific secrets in a single JSON string inside an environment variable (e.g., USER_TOKENS).
	2.	Updating this variable dynamically when a new user logs in.
	3.	Ensuring the variable is retained across application restarts using Kubernetes ConfigMap or Secret.

⸻

Updated Flask Code to Use ENV Variable for Tokens

import os
import jwt
import json
import secrets
from flask import Flask, request, jsonify

app = Flask(__name__)

# Default value for user tokens (stored as JSON in ENV variable)
USER_TOKENS_ENV = os.getenv("USER_TOKENS", "{}")

def load_user_tokens():
    """Load user-specific secrets from environment variable."""
    try:
        return json.loads(USER_TOKENS_ENV)  # Convert JSON string to dict
    except json.JSONDecodeError:
        return {}

def save_user_tokens(tokens):
    """Save user-specific secrets back to environment variable."""
    os.environ["USER_TOKENS"] = json.dumps(tokens)  # Store as JSON string

USER_TOKENS = load_user_tokens()

@app.route("/generate_token", methods=["POST"])
def generate_token():
    data = request.json
    username = data.get("username")

    if not username:
        return jsonify({"error": "Username is required"}), 400

    # Generate a unique secret for this user if not already present
    if username not in USER_TOKENS:
        USER_TOKENS[username] = secrets.token_hex(32)  # 256-bit random secret
        save_user_tokens(USER_TOKENS)  # Save to environment variable

    user_secret = USER_TOKENS[username]

    # Generate JWT token with no expiration
    token = jwt.encode({"username": username}, user_secret, algorithm="HS256")

    return jsonify({"token": token})

@app.route("/verify_token", methods=["POST"])
def verify_token():
    data = request.json
    username = data.get("username")
    token = data.get("token")

    if not username or not token:
        return jsonify({"error": "Username and token are required"}), 400

    user_secret = USER_TOKENS.get(username)

    if not user_secret:
        return jsonify({"error": "User secret not found"}), 403

    try:
        decoded = jwt.decode(token, user_secret, algorithms=["HS256"])
        if decoded.get("username") == username:
            return jsonify({"message": "Token is valid"})
    except jwt.InvalidTokenError:
        return jsonify({"error": "Invalid token"}), 403

    return jsonify({"error": "Authentication failed"}), 403

if __name__ == "__main__":
    app.run(debug=True)



⸻

How This Works
	1.	First Login → Generate Token
	•	When a user logs in, a unique secret is generated and stored inside the USER_TOKENS environment variable as a JSON string.
	•	A JWT token is generated using this secret and returned.
	2.	Subsequent Requests → Validate Token
	•	The user sends the JWT with each request.
	•	The server verifies it using the user-specific secret.
	3.	Token Never Expires
	•	Since no exp (expiration) is added, the token remains valid indefinitely.
	4.	Secrets Persist in Kubernetes
	•	Use a Kubernetes ConfigMap or Secret to store USER_TOKENS persistently.

⸻

Making It Persistent in Kubernetes

Since environment variables reset on pod restarts, you must use a Kubernetes ConfigMap or Secret:

A. Using Kubernetes ConfigMap for Tokens

apiVersion: v1
kind: ConfigMap
metadata:
  name: user-tokens-config
data:
  USER_TOKENS: "{}"

B. Mount It in Deployment

apiVersion: apps/v1
kind: Deployment
metadata:
  name: interactive-service
spec:
  replicas: 1
  selector:
    matchLabels:
      app: interactive-service
  template:
    metadata:
      labels:
        app: interactive-service
    spec:
      containers:
      - name: interactive-service
        image: your-image:latest
        env:
        - name: USER_TOKENS
          valueFrom:
            configMapKeyRef:
              name: user-tokens-config
              key: USER_TOKENS



⸻

Will It Expire on Container Restart?
	•	By Default: Yes.
Since os.environ resets on restart, tokens will be lost.
	•	Solution: Use Kubernetes ConfigMap or Secret
	•	If you store USER_TOKENS in a Kubernetes ConfigMap/Secret, it will persist across restarts.
	•	On restart, Flask loads it back from the ConfigMap.

⸻

Final Notes

✅ Each user gets a unique token
✅ Tokens survive container restarts (via Kubernetes ConfigMap)
✅ Session never expires
✅ Only interactive service can issue tokens
✅ No need for a global JWT_SECRET

Would you like to store the tokens in an external Redis or database instead of a ConfigMap?

Below is a final solution that uses JWT for interactive authentication without expiration. In this setup, when a user logs into the interactive service, a new JWT is generated for that user (without an expiration field), and this token is used on subsequent AJAX calls. In your Kubernetes Deployment, you simply need to provide the JWT secret as an environment variable.

⸻

1. Flask App (app.py)

import os
import json
import bcrypt
import jwt  # PyJWT
from flask import Flask, request, render_template, jsonify
from functools import wraps

app = Flask(__name__)
app.secret_key = os.urandom(24)  # Not used for JWT, but required for sessions if needed

# Load user tokens (hashed passwords and API tokens) from an environment variable.
# Expected format example:
# {
#    "user1": { "secret": "$2b$12$abc...", "api_token": "token1" },
#    "user2": { "secret": "$2b$12$def...", "api_token": "token2" }
# }
USER_TOKENS = json.loads(os.getenv("USER_AUTH_TOKENS", "{}"))

# JWT secret (set this in your deployment environment)
JWT_SECRET = os.getenv("JWT_SECRET", "default_jwt_secret")
JWT_ALGORITHM = "HS256"

def verify_token(username, provided_token):
    """
    Verify that the provided plaintext token matches the stored bcrypt hash.
    """
    user_data = USER_TOKENS.get(username)
    if not user_data:
        app.logger.warning(f"Token not found for user: {username}")
        return False
    stored_hash = user_data.get("secret")
    try:
        return bcrypt.checkpw(provided_token.encode("utf-8"), stored_hash.encode("utf-8"))
    except Exception as e:
        app.logger.error(f"Error verifying token for {username}: {e}")
        return False

@app.route('/interactive_jira', methods=['GET'])
def interactive_jira():
    """
    Interactive service endpoint.
    Expects:
      - Query parameter 'username'
      - Authorization header in the form "Bearer <plaintext_password>"
    If authentication passes, generate a JWT (without expiration) for that user and render the interactive page.
    """
    username = request.args.get('username')
    auth_header = request.headers.get("Authorization")

    if not username or not auth_header or not auth_header.startswith("Bearer "):
        return jsonify({"error": "Invalid credentials"}), 401

    provided_token = auth_header.split(" ")[1]
    if not verify_token(username, provided_token):
        return jsonify({"error": "Unauthorized"}), 403

    # Generate a JWT for the user without an expiration (not recommended for production unless you have other measures)
    payload = {"username": username}
    token = jwt.encode(payload, JWT_SECRET, algorithm=JWT_ALGORITHM)
    # If using PyJWT >= 2.x, token is a string; if bytes, decode it.
    if isinstance(token, bytes):
        token = token.decode("utf-8")

    return render_template("interactive.html", username=username, secret_token=token)

def require_jwt(f):
    """
    Decorator that checks that the request includes a valid JWT in header "X-Interactive-Token"
    and that the token's username matches the header "X-Interactive-User".
    """
    @wraps(f)
    def wrapper(*args, **kwargs):
        username = request.headers.get("X-Interactive-User")
        token = request.headers.get("X-Interactive-Token")
        if not username or not token:
            return jsonify({"error": "Missing interactive authentication headers"}), 403
        try:
            payload = jwt.decode(token, JWT_SECRET, algorithms=[JWT_ALGORITHM])
            if payload.get("username") != username:
                return jsonify({"error": "Username mismatch in token"}), 403
        except jwt.ExpiredSignatureError:
            return jsonify({"error": "Token expired"}), 403
        except jwt.InvalidTokenError as e:
            return jsonify({"error": f"Invalid token: {e}"}), 403
        return f(*args, **kwargs)
    return wrapper

@app.route('/update_comment', methods=['POST', 'OPTIONS'])
@require_jwt
def update_comment():
    data = request.json
    jira_number = data.get("jira_number")
    comment = data.get("comment")
    if not jira_number or not comment:
        return jsonify({"error": "Missing jira_number or comment"}), 400
    # Here, add your logic to update comment in JIRA/DB.
    return jsonify({"message": f"Comment updated for JIRA {jira_number}."}), 200

@app.route('/resolve_status', methods=['POST', 'OPTIONS'])
@require_jwt
def resolve_status():
    data = request.json
    jira_number = data.get("jira_number")
    if not jira_number:
        return jsonify({"error": "Missing jira_number"}), 400
    # Here, add your logic to resolve the JIRA issue.
    return jsonify({"message": f"Issue {jira_number} resolved successfully."}), 200

@app.route('/refresh_table', methods=['POST', 'OPTIONS'])
@require_jwt
def refresh_table():
    # Here, add your logic to refresh the table (e.g., fetching latest data)
    return jsonify({"message": "Table refreshed successfully."}), 200

@app.route('/logout', methods=['POST'])
def logout():
    # Since we don't use a session, just instruct the client to discard the token.
    return jsonify({"message": "Please discard your token to log out."}), 200

if __name__ == '__main__':
    app.run(debug=True)



⸻

2. HTML Template (templates/interactive.html)

This template is rendered after a successful login. It injects the username and the secret token (JWT) into JavaScript variables for subsequent AJAX calls.

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>JIRA Interactive Service</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        table { width: 100%; border-collapse: collapse; margin-top: 20px; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #f4f4f4; }
        button { margin: 5px; padding: 5px 10px; }
        .collapsible {
            background-color: #eee;
            border: none;
            cursor: pointer;
            padding: 4px;
            width: 100%;
            text-align: left;
            font-size: 13px;
            margin-bottom: 2px;
            outline: none;
        }
        .collapsible:after {
            content: '\002B';
            float: right;
            margin-left: 5px;
        }
        .collapsible.active:after {
            content: "\2212";
        }
        .content {
            display: none;
            padding: 4px;
            background-color: #f9f9f9;
            margin-bottom: 4px;
            font-size: 12px;
        }
    </style>
    <script>
        // These values are injected by Flask
        const SECRET_TOKEN = "{{ secret_token }}";
        const USERNAME = "{{ username }}";

        async function apiCall(endpoint, data = {}) {
            try {
                const response = await fetch(endpoint, {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                        "X-Interactive-User": USERNAME,
                        "X-Interactive-Token": SECRET_TOKEN
                    },
                    body: JSON.stringify(data)
                });
                const result = await response.json();
                alert(result.message);
                if (response.ok) {
                    window.location.reload();
                }
            } catch (error) {
                alert("Error: " + error);
            }
        }

        function updateComment(jiraNumber) {
            const comment = prompt("Enter your comment for " + jiraNumber + ":");
            if (comment) {
                apiCall("/update_comment", { jira_number: jiraNumber, comment: comment });
            }
        }

        function resolveStatus(jiraNumber) {
            if (confirm("Are you sure you want to resolve " + jiraNumber + "?")) {
                apiCall("/resolve_status", { jira_number: jiraNumber });
            }
        }

        function refreshTable() {
            apiCall("/refresh_table");
        }

        document.addEventListener("DOMContentLoaded", function(){
            var coll = document.getElementsByClassName("collapsible");
            for (let i = 0; i < coll.length; i++) {
                coll[i].addEventListener("click", function() {
                    this.classList.toggle("active");
                    let content = this.nextElementSibling;
                    content.style.display = content.style.display === "block" ? "none" : "block";
                });
            }
        });
    </script>
</head>
<body>
    <h2>Welcome, {{ username }}!</h2>
    <button onclick="refreshTable()">Refresh Table</button>
    <table>
        <thead>
            <tr>
                <th>JIRA Number</th>
                <th>Summary</th>
                <th>Actions</th>
                <th>Comments</th>
            </tr>
        </thead>
        <tbody>
            <!-- Example row; in production, rows would be generated dynamically -->
            <tr>
                <td>JIRA-123</td>
                <td>Fix login issue</td>
                <td>
                    <button onclick="updateComment('JIRA-123')">Update Comment</button>
                    <button onclick="resolveStatus('JIRA-123')">Resolve Status</button>
                </td>
                <td>
                    <button class="collapsible">1. 2023-07-01 10:00 - Alice</button>
                    <div class="content">
                        <p>Initial comment text.</p>
                    </div>
                    <button class="collapsible">2. 2023-07-01 11:00 - Bob</button>
                    <div class="content">
                        <p>Follow-up comment text.</p>
                    </div>
                </td>
            </tr>
        </tbody>
    </table>
</body>
</html>



⸻

3. Deployment Considerations

In your Kubernetes Deployment YAML, set the environment variables for USER_AUTH_TOKENS and JWT_SECRET. For example:

apiVersion: apps/v1
kind: Deployment
metadata:
  name: jira-interactive
spec:
  replicas: 1
  selector:
    matchLabels:
      app: jira-interactive
  template:
    metadata:
      labels:
        app: jira-interactive
    spec:
      containers:
        - name: jira-interactive
          image: yourrepo/jira-interactive:latest
          env:
            - name: USER_AUTH_TOKENS
              value: '{"user1": {"secret": "$2b$12$abc...", "api_token": "token1"}, "user2": {"secret": "$2b$12$def...", "api_token": "token2"}}'
            - name: JWT_SECRET
              value: "your_jwt_secret"
          ports:
            - containerPort: 5000



⸻

Summary
	•	Interactive Login:
The user logs in via /interactive_jira?username=... with an Authorization header. If authentication passes (via bcrypt), a JWT token (without expiration) is generated and passed to the HTML template.
	•	Subsequent Requests:
All subsequent AJAX requests (update_comment, resolve_status, refresh_table) include headers:
	•	X-Interactive-User: the username
	•	X-Interactive-Token: the generated JWT token
The custom decorator (@require_jwt) verifies the token for that user.
	•	Deployment:
Set USER_AUTH_TOKENS (a JSON string) and JWT_SECRET as environment variables in your Kubernetes Deployment.

This approach ensures that each user gets their own permanent interactive token without needing Flask sessions, and subsequent requests require the correct token in headers. Let me know if you need further modifications!