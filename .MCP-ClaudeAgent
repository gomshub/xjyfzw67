
Got it ‚úÖ ‚Äî you want a true native desktop app (like Claude Desktop),
not a browser-based Streamlit UI.

Let‚Äôs build that version using PyQt6, which runs beautifully inside AWS End User Computing (EUC) (WorkSpaces or AppStream).

This app will:
	‚Ä¢	Open a real window on your desktop (not in a browser).
	‚Ä¢	Let you chat with your on-prem MCP Server.
	‚Ä¢	Use AWS Bedrock (Claude or Titan) for LLM reasoning.
	‚Ä¢	Display both raw MCP results and the natural-language LLM response.

‚∏ª

üß© Folder setup

Create a project folder:

mcp_desktop_gui/
 ‚îú‚îÄ‚îÄ mcp_desktop_gui.py   ‚Üê main file
 ‚îú‚îÄ‚îÄ requirements.txt


‚∏ª

üß∞ requirements.txt

PyQt6
boto3
requests

Install:

pip install -r requirements.txt


‚∏ª

ü™ü mcp_desktop_gui.py

import sys
import json
import requests
import boto3
from PyQt6.QtWidgets import (
    QApplication, QWidget, QVBoxLayout, QLabel,
    QTextEdit, QPushButton, QLineEdit, QHBoxLayout, QMessageBox
)
from PyQt6.QtCore import Qt

class MCPDesktopApp(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Claude Desktop (Private MCP + Bedrock)")
        self.setMinimumSize(800, 600)
        self.layout = QVBoxLayout()

        # MCP + Bedrock Config
        self.url_label = QLabel("üîó MCP Server URL:")
        self.url_input = QLineEdit("https://mcp-server.onprem.mycompany.com:8080")

        self.model_label = QLabel("üß† Bedrock Model ID:")
        self.model_input = QLineEdit("anthropic.claude-3-sonnet-20240229-v1:0")

        url_layout = QHBoxLayout()
        url_layout.addWidget(self.url_label)
        url_layout.addWidget(self.url_input)
        self.layout.addLayout(url_layout)

        model_layout = QHBoxLayout()
        model_layout.addWidget(self.model_label)
        model_layout.addWidget(self.model_input)
        self.layout.addLayout(model_layout)

        # Chat input
        self.query_label = QLabel("üí≠ Ask me anything:")
        self.query_box = QTextEdit()
        self.query_box.setPlaceholderText("Type your question here...")
        self.query_box.setFixedHeight(100)

        self.layout.addWidget(self.query_label)
        self.layout.addWidget(self.query_box)

        # Ask button
        self.ask_button = QPushButton("üöÄ Ask")
        self.ask_button.clicked.connect(self.handle_query)
        self.layout.addWidget(self.ask_button)

        # Output area
        self.mcp_result_label = QLabel("üìä MCP Server Response:")
        self.mcp_result = QTextEdit()
        self.mcp_result.setReadOnly(True)

        self.llm_result_label = QLabel("ü§ñ Claude Response:")
        self.llm_result = QTextEdit()
        self.llm_result.setReadOnly(True)

        self.layout.addWidget(self.mcp_result_label)
        self.layout.addWidget(self.mcp_result)
        self.layout.addWidget(self.llm_result_label)
        self.layout.addWidget(self.llm_result)

        self.setLayout(self.layout)

    # --------------------------
    # Backend calls
    # --------------------------
    def handle_query(self):
        query = self.query_box.toPlainText().strip()
        if not query:
            QMessageBox.warning(self, "Input Required", "Please type a question first.")
            return

        mcp_url = self.url_input.text().strip()
        model_id = self.model_input.text().strip()

        try:
            self.mcp_result.setPlainText("Querying MCP Server...")
            mcp_data = self.call_mcp_server(mcp_url, query)
            self.mcp_result.setPlainText(json.dumps(mcp_data, indent=2))
        except Exception as e:
            self.mcp_result.setPlainText(f"‚ùå Error contacting MCP Server:\n{e}")
            return

        try:
            self.llm_result.setPlainText("Calling Bedrock LLM (Claude)...")
            context = (
                f"The MCP server returned this data:\n{json.dumps(mcp_data, indent=2)}\n\n"
                f"Now answer the user query conversationally: {query}"
            )
            answer = self.call_bedrock_llm(context, model_id)
            self.llm_result.setPlainText(answer)
        except Exception as e:
            self.llm_result.setPlainText(f"‚ùå Error calling Bedrock LLM:\n{e}")

    def call_mcp_server(self, mcp_url, query, verify_ssl=False):
        payload = {"input": query}
        resp = requests.post(
            f"{mcp_url}/infer",
            json=payload,
            verify=verify_ssl,
            timeout=60
        )
        resp.raise_for_status()
        return resp.json()

    def call_bedrock_llm(self, prompt, model_id, region="eu-central-1"):
        bedrock = boto3.client("bedrock-runtime", region_name=region)
        body = json.dumps({
            "prompt": f"Human: {prompt}\nAssistant:",
            "max_tokens": 400,
            "temperature": 0.7,
        })
        response = bedrock.invoke_model(
            modelId=model_id,
            body=body,
            contentType="application/json"
        )
        data = response["body"].read().decode("utf-8")
        return json.loads(data).get("completion", data)


if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = MCPDesktopApp()
    window.show()
    sys.exit(app.exec())


‚∏ª

üöÄ Run it on EUC

python mcp_desktop_gui.py

This opens a real window, just like any desktop app:

‚∏ª

üñºÔ∏è Interface layout

+----------------------------------------------------------+
| Claude Desktop (Private MCP + Bedrock)                   |
+----------------------------------------------------------+
| üîó MCP Server URL:  [ https://mcp-server.onprem.mycompany.com:8080 ]  |
| üß† Bedrock Model ID: [ anthropic.claude-3-sonnet-20240229-v1:0 ]     |
+----------------------------------------------------------+
| üí≠ Ask me anything:                                      |
| [ Summarize today‚Äôs ingestion errors...           ]      |
|                   [üöÄ Ask]                               |
+----------------------------------------------------------+
| üìä MCP Server Response:                                  |
| {                                                        |
|   "records": 10520, "errors": 12                         |
| }                                                        |
+----------------------------------------------------------+
| ü§ñ Claude Response:                                      |
| "The MCP server processed 10,520 records with 12 errors" |
+----------------------------------------------------------+


‚∏ª

üîê Security & Deployment Notes

Item	Recommendation
TLS	Use real cert or disable SSL verify if self-signed
IAM	Attach Bedrock permissions to EUC instance or use AWS credentials
Firewall	Outbound HTTPS (443) from EUC ‚Üí MCP Server
Packaging	Optional: use pyinstaller --onefile mcp_desktop_gui.py to create a .exe or .app


‚∏ª

‚úÖ Summary

Component	Location	Purpose
MCP Server	On-prem Kube	Data provider
PyQt Desktop App	AWS EUC	Native Claude-like GUI
AWS Bedrock	AWS	LLM reasoning
Firewall	EUC ‚Üí On-prem HTTPS	Secure connectivity


‚∏ª

Would you like me to extend this PyQt GUI so it:
	1.	Keeps chat history (scrolling conversation) like Claude Desktop, and/or
	2.	Adds authentication (API key) for the on-prem MCP Server?




Perfect ‚úÖ ‚Äî you want to test only the MCP integration (on-prem ‚Üí EUC) first,
and skip connecting to AWS Bedrock until that‚Äôs working.

That‚Äôs a smart move ‚Äî let‚Äôs simplify the GUI so it behaves exactly like Claude Desktop,
but only uses your on-prem MCP server (no AWS Bedrock calls, no cloud dependency).

‚∏ª

üß© Minimal MCP-only version

Just replace your mcp_desktop_gui.py content with the code below.

üöÄ mcp_desktop_gui.py

import sys
import json
import requests
from PyQt6.QtWidgets import (
    QApplication, QWidget, QVBoxLayout, QLabel,
    QTextEdit, QPushButton, QLineEdit, QHBoxLayout, QMessageBox
)
from PyQt6.QtCore import Qt

class MCPDesktopApp(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Claude Desktop - MCP Only")
        self.setMinimumSize(800, 600)
        self.layout = QVBoxLayout()

        # MCP Config
        self.url_label = QLabel("üîó MCP Server URL:")
        self.url_input = QLineEdit("https://mcp-server.onprem.mycompany.com:8080")

        url_layout = QHBoxLayout()
        url_layout.addWidget(self.url_label)
        url_layout.addWidget(self.url_input)
        self.layout.addLayout(url_layout)

        # Chat input
        self.query_label = QLabel("üí≠ Ask me anything:")
        self.query_box = QTextEdit()
        self.query_box.setPlaceholderText("Type your question here...")
        self.query_box.setFixedHeight(100)

        self.layout.addWidget(self.query_label)
        self.layout.addWidget(self.query_box)

        # Ask button
        self.ask_button = QPushButton("üöÄ Send to MCP Server")
        self.ask_button.clicked.connect(self.handle_query)
        self.layout.addWidget(self.ask_button)

        # Output area
        self.mcp_result_label = QLabel("üìä MCP Server Response:")
        self.mcp_result = QTextEdit()
        self.mcp_result.setReadOnly(True)

        self.layout.addWidget(self.mcp_result_label)
        self.layout.addWidget(self.mcp_result)

        self.setLayout(self.layout)

    # --------------------------
    # Backend call to MCP only
    # --------------------------
    def handle_query(self):
        query = self.query_box.toPlainText().strip()
        if not query:
            QMessageBox.warning(self, "Input Required", "Please type a question first.")
            return

        mcp_url = self.url_input.text().strip()

        try:
            self.mcp_result.setPlainText("‚è≥ Sending query to MCP Server...")
            response = self.call_mcp_server(mcp_url, query)
            self.mcp_result.setPlainText(json.dumps(response, indent=2))
        except Exception as e:
            self.mcp_result.setPlainText(f"‚ùå Error contacting MCP Server:\n{e}")

    def call_mcp_server(self, mcp_url, query, verify_ssl=False):
        payload = {"input": query}
        resp = requests.post(
            f"{mcp_url}/infer",
            json=payload,
            verify=verify_ssl,  # Set to True if using trusted SSL cert
            timeout=60
        )
        resp.raise_for_status()
        return resp.json()


if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = MCPDesktopApp()
    window.show()
    sys.exit(app.exec())


‚∏ª

üí° What This Version Does

Feature	Description
üß© MCP-only	Sends your input to your on-prem MCP server
üñ•Ô∏è GUI	Same PyQt desktop window (works in EUC)
üîÑ Response	Displays raw JSON/text from your MCP endpoint
‚ùå Bedrock	Removed entirely (no cloud, no LLM)
üîê SSL toggle	Can disable SSL verify for self-signed certs


‚∏ª

üß™ Example Flow
	1.	Start your EUC desktop session
	2.	Run the GUI:

python mcp_desktop_gui.py


	3.	Enter your on-prem MCP endpoint, e.g.

https://mcp-server.onprem.mycompany.com:8080


	4.	Type a query such as:

get latest metrics for pipeline A


	5.	Click üöÄ Send to MCP Server
	6.	You‚Äôll see:

{
  "records": 10520,
  "errors": 12,
  "status": "healthy"
}



‚∏ª

üîç Debugging Tips

Issue	Resolution
‚ùå SSL certificate error	Set verify_ssl=False in call_mcp_server()
‚ùå Connection refused	Check firewall or kube ingress
üß± EUC cannot reach on-prem	Verify EUC ‚Üí on-prem HTTPS access (443)
üßæ MCP expects auth header	Add headers in requests.post() (I can show you how)


‚∏ª

‚úÖ Next Step Options

Once this GUI confirms you can talk to the MCP server successfully,
you can then extend it in one line to re-enable Bedrock integration later.

Would you like me to show you how to add authentication headers (username/token) to this MCP-only GUI next?
That‚Äôs often needed for secure on-prem setups.