
Excellent and very practical question ğŸ‘ â€”
youâ€™re thinking exactly like a DevOps engineer who wants to keep deployment simple inside EUC.

Letâ€™s break this down carefully:

â¸»

âš™ï¸ Why PyQt vs Browser-based (Streamlit or FastAPI UI)

Comparison	PyQt GUI (desktop app)	Browser-based GUI (Streamlit / FastAPI + React)
Access method	Opens as a native desktop window on the EUC	Accessed via browser (e.g., http://localhost:8501)
Hosting requirement	Runs directly in EUC (no server)	Needs a lightweight web server (Streamlit/FastAPI)
Firewall complexity	Only outbound HTTPS to MCP server	Same â€” but open local port (e.g. 8501) in EUC
User interface style	Feels like Claude Desktop (standalone window)	Feels like a modern web app (like ChatGPT/Claude web)
Multi-user support	Single user per desktop	Easier to share among users (browser access)
Deployment in AWS EUC	Installable EXE or python mcp_desktop_gui.py	Just run streamlit run app.py and open browser
Packaging	Needs PyInstaller for EXE	No packaging needed
Look & feel	Closer to a native chat app	More flexible for quick prototyping & dashboards


â¸»

ğŸ’¡ In Your Case (EUC + On-prem MCP + Bedrock)

You actually have both options valid â€” but each suits a different goal:

âœ… Option 1: PyQt (Claude Desktop-style)
	â€¢	Good if you want a true desktop experience inside EUC (no browser tab).
	â€¢	Best for single user or test bench setup.
	â€¢	Runs even if browser policies are strict in EUC.

âœ… Option 2: Browser-based Streamlit App (recommended for simplicity)
	â€¢	No special GUI libraries.
	â€¢	Very quick to test and share.
	â€¢	Easier to containerize or deploy on EUC WorkSpaces or even as a small ECS app.
	â€¢	Uses the same code flow â€” just rendered as a web chat page.

â¸»

ğŸ§  So yes â€” you can absolutely access it from a browser.

Let me show you that equivalent browser-based version ğŸ‘‡
that works exactly like the MCP-only PyQt app you saw earlier â€” just open via browser.

â¸»

ğŸŒ Streamlit version â€” â€œClaude Desktop (Browser GUI, MCP-only)â€

mcp_desktop_browser.py

import streamlit as st
import requests
import json

st.set_page_config(page_title="Claude Desktop - MCP Only", layout="wide")

st.title("ğŸ’¬ Claude Desktop (Browser UI - MCP Only)")

# MCP URL input
mcp_url = st.text_input("ğŸ”— MCP Server URL", "https://mcp-server.onprem.mycompany.com:8080")

# Query input
query = st.text_area("ğŸ’­ Ask me anything:", placeholder="Type your question here...")

if st.button("ğŸš€ Send to MCP Server"):
    if not query:
        st.warning("Please enter a query first.")
    else:
        try:
            st.info("â³ Sending query to MCP Server...")
            payload = {"input": query}
            response = requests.post(f"{mcp_url}/infer", json=payload, verify=False, timeout=60)
            response.raise_for_status()
            data = response.json()
            st.success("âœ… MCP Server Response:")
            st.json(data)
        except Exception as e:
            st.error(f"âŒ Error contacting MCP Server: {e}")


â¸»

ğŸš€ Run it

pip install streamlit requests
streamlit run mcp_desktop_browser.py

Then open the link printed in your EUC terminal, e.g.:

Local URL: http://localhost:8501

It opens a Claude-like chat page in your browser (inside EUC).

â¸»

ğŸ–¥ï¸ What Youâ€™ll See

ğŸ’¬ Claude Desktop (Browser UI - MCP Only)
-------------------------------------------------
ğŸ”— MCP Server URL: [https://mcp-server.onprem.mycompany.com:8080]
ğŸ’­ Ask me anything:
[ get pipeline health metrics ]    [ğŸš€ Send]
-------------------------------------------------
âœ… MCP Server Response:
{
  "records": 10520,
  "errors": 12,
  "status": "healthy"
}


â¸»

âœ… Recommended approach for you

Since youâ€™re running in AWS EUC with firewall open to on-prem,
and just need to hit the MCP API and see responses:

ğŸ‘‰ Use the Streamlit (browser) version first
Itâ€™s easier to run, debug, and later extend with Bedrock integration.

â¸»

Would you like me to extend this Streamlit (browser) version so that it:
	â€¢	Maintains chat history (Claude-like), and
	â€¢	Later can easily plug in Bedrock when ready?



Got it âœ… â€” you want a true native desktop app (like Claude Desktop),
not a browser-based Streamlit UI.

Letâ€™s build that version using PyQt6, which runs beautifully inside AWS End User Computing (EUC) (WorkSpaces or AppStream).

This app will:
	â€¢	Open a real window on your desktop (not in a browser).
	â€¢	Let you chat with your on-prem MCP Server.
	â€¢	Use AWS Bedrock (Claude or Titan) for LLM reasoning.
	â€¢	Display both raw MCP results and the natural-language LLM response.

â¸»

ğŸ§© Folder setup

Create a project folder:

mcp_desktop_gui/
 â”œâ”€â”€ mcp_desktop_gui.py   â† main file
 â”œâ”€â”€ requirements.txt


â¸»

ğŸ§° requirements.txt

PyQt6
boto3
requests

Install:

pip install -r requirements.txt


â¸»

ğŸªŸ mcp_desktop_gui.py

import sys
import json
import requests
import boto3
from PyQt6.QtWidgets import (
    QApplication, QWidget, QVBoxLayout, QLabel,
    QTextEdit, QPushButton, QLineEdit, QHBoxLayout, QMessageBox
)
from PyQt6.QtCore import Qt

class MCPDesktopApp(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Claude Desktop (Private MCP + Bedrock)")
        self.setMinimumSize(800, 600)
        self.layout = QVBoxLayout()

        # MCP + Bedrock Config
        self.url_label = QLabel("ğŸ”— MCP Server URL:")
        self.url_input = QLineEdit("https://mcp-server.onprem.mycompany.com:8080")

        self.model_label = QLabel("ğŸ§  Bedrock Model ID:")
        self.model_input = QLineEdit("anthropic.claude-3-sonnet-20240229-v1:0")

        url_layout = QHBoxLayout()
        url_layout.addWidget(self.url_label)
        url_layout.addWidget(self.url_input)
        self.layout.addLayout(url_layout)

        model_layout = QHBoxLayout()
        model_layout.addWidget(self.model_label)
        model_layout.addWidget(self.model_input)
        self.layout.addLayout(model_layout)

        # Chat input
        self.query_label = QLabel("ğŸ’­ Ask me anything:")
        self.query_box = QTextEdit()
        self.query_box.setPlaceholderText("Type your question here...")
        self.query_box.setFixedHeight(100)

        self.layout.addWidget(self.query_label)
        self.layout.addWidget(self.query_box)

        # Ask button
        self.ask_button = QPushButton("ğŸš€ Ask")
        self.ask_button.clicked.connect(self.handle_query)
        self.layout.addWidget(self.ask_button)

        # Output area
        self.mcp_result_label = QLabel("ğŸ“Š MCP Server Response:")
        self.mcp_result = QTextEdit()
        self.mcp_result.setReadOnly(True)

        self.llm_result_label = QLabel("ğŸ¤– Claude Response:")
        self.llm_result = QTextEdit()
        self.llm_result.setReadOnly(True)

        self.layout.addWidget(self.mcp_result_label)
        self.layout.addWidget(self.mcp_result)
        self.layout.addWidget(self.llm_result_label)
        self.layout.addWidget(self.llm_result)

        self.setLayout(self.layout)

    # --------------------------
    # Backend calls
    # --------------------------
    def handle_query(self):
        query = self.query_box.toPlainText().strip()
        if not query:
            QMessageBox.warning(self, "Input Required", "Please type a question first.")
            return

        mcp_url = self.url_input.text().strip()
        model_id = self.model_input.text().strip()

        try:
            self.mcp_result.setPlainText("Querying MCP Server...")
            mcp_data = self.call_mcp_server(mcp_url, query)
            self.mcp_result.setPlainText(json.dumps(mcp_data, indent=2))
        except Exception as e:
            self.mcp_result.setPlainText(f"âŒ Error contacting MCP Server:\n{e}")
            return

        try:
            self.llm_result.setPlainText("Calling Bedrock LLM (Claude)...")
            context = (
                f"The MCP server returned this data:\n{json.dumps(mcp_data, indent=2)}\n\n"
                f"Now answer the user query conversationally: {query}"
            )
            answer = self.call_bedrock_llm(context, model_id)
            self.llm_result.setPlainText(answer)
        except Exception as e:
            self.llm_result.setPlainText(f"âŒ Error calling Bedrock LLM:\n{e}")

    def call_mcp_server(self, mcp_url, query, verify_ssl=False):
        payload = {"input": query}
        resp = requests.post(
            f"{mcp_url}/infer",
            json=payload,
            verify=verify_ssl,
            timeout=60
        )
        resp.raise_for_status()
        return resp.json()

    def call_bedrock_llm(self, prompt, model_id, region="eu-central-1"):
        bedrock = boto3.client("bedrock-runtime", region_name=region)
        body = json.dumps({
            "prompt": f"Human: {prompt}\nAssistant:",
            "max_tokens": 400,
            "temperature": 0.7,
        })
        response = bedrock.invoke_model(
            modelId=model_id,
            body=body,
            contentType="application/json"
        )
        data = response["body"].read().decode("utf-8")
        return json.loads(data).get("completion", data)


if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = MCPDesktopApp()
    window.show()
    sys.exit(app.exec())


â¸»

ğŸš€ Run it on EUC

python mcp_desktop_gui.py

This opens a real window, just like any desktop app:

â¸»

ğŸ–¼ï¸ Interface layout

+----------------------------------------------------------+
| Claude Desktop (Private MCP + Bedrock)                   |
+----------------------------------------------------------+
| ğŸ”— MCP Server URL:  [ https://mcp-server.onprem.mycompany.com:8080 ]  |
| ğŸ§  Bedrock Model ID: [ anthropic.claude-3-sonnet-20240229-v1:0 ]     |
+----------------------------------------------------------+
| ğŸ’­ Ask me anything:                                      |
| [ Summarize todayâ€™s ingestion errors...           ]      |
|                   [ğŸš€ Ask]                               |
+----------------------------------------------------------+
| ğŸ“Š MCP Server Response:                                  |
| {                                                        |
|   "records": 10520, "errors": 12                         |
| }                                                        |
+----------------------------------------------------------+
| ğŸ¤– Claude Response:                                      |
| "The MCP server processed 10,520 records with 12 errors" |
+----------------------------------------------------------+


â¸»

ğŸ” Security & Deployment Notes

Item	Recommendation
TLS	Use real cert or disable SSL verify if self-signed
IAM	Attach Bedrock permissions to EUC instance or use AWS credentials
Firewall	Outbound HTTPS (443) from EUC â†’ MCP Server
Packaging	Optional: use pyinstaller --onefile mcp_desktop_gui.py to create a .exe or .app


â¸»

âœ… Summary

Component	Location	Purpose
MCP Server	On-prem Kube	Data provider
PyQt Desktop App	AWS EUC	Native Claude-like GUI
AWS Bedrock	AWS	LLM reasoning
Firewall	EUC â†’ On-prem HTTPS	Secure connectivity


â¸»

Would you like me to extend this PyQt GUI so it:
	1.	Keeps chat history (scrolling conversation) like Claude Desktop, and/or
	2.	Adds authentication (API key) for the on-prem MCP Server?




Perfect âœ… â€” you want to test only the MCP integration (on-prem â†’ EUC) first,
and skip connecting to AWS Bedrock until thatâ€™s working.

Thatâ€™s a smart move â€” letâ€™s simplify the GUI so it behaves exactly like Claude Desktop,
but only uses your on-prem MCP server (no AWS Bedrock calls, no cloud dependency).

â¸»

ğŸ§© Minimal MCP-only version

Just replace your mcp_desktop_gui.py content with the code below.

ğŸš€ mcp_desktop_gui.py

import sys
import json
import requests
from PyQt6.QtWidgets import (
    QApplication, QWidget, QVBoxLayout, QLabel,
    QTextEdit, QPushButton, QLineEdit, QHBoxLayout, QMessageBox
)
from PyQt6.QtCore import Qt

class MCPDesktopApp(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Claude Desktop - MCP Only")
        self.setMinimumSize(800, 600)
        self.layout = QVBoxLayout()

        # MCP Config
        self.url_label = QLabel("ğŸ”— MCP Server URL:")
        self.url_input = QLineEdit("https://mcp-server.onprem.mycompany.com:8080")

        url_layout = QHBoxLayout()
        url_layout.addWidget(self.url_label)
        url_layout.addWidget(self.url_input)
        self.layout.addLayout(url_layout)

        # Chat input
        self.query_label = QLabel("ğŸ’­ Ask me anything:")
        self.query_box = QTextEdit()
        self.query_box.setPlaceholderText("Type your question here...")
        self.query_box.setFixedHeight(100)

        self.layout.addWidget(self.query_label)
        self.layout.addWidget(self.query_box)

        # Ask button
        self.ask_button = QPushButton("ğŸš€ Send to MCP Server")
        self.ask_button.clicked.connect(self.handle_query)
        self.layout.addWidget(self.ask_button)

        # Output area
        self.mcp_result_label = QLabel("ğŸ“Š MCP Server Response:")
        self.mcp_result = QTextEdit()
        self.mcp_result.setReadOnly(True)

        self.layout.addWidget(self.mcp_result_label)
        self.layout.addWidget(self.mcp_result)

        self.setLayout(self.layout)

    # --------------------------
    # Backend call to MCP only
    # --------------------------
    def handle_query(self):
        query = self.query_box.toPlainText().strip()
        if not query:
            QMessageBox.warning(self, "Input Required", "Please type a question first.")
            return

        mcp_url = self.url_input.text().strip()

        try:
            self.mcp_result.setPlainText("â³ Sending query to MCP Server...")
            response = self.call_mcp_server(mcp_url, query)
            self.mcp_result.setPlainText(json.dumps(response, indent=2))
        except Exception as e:
            self.mcp_result.setPlainText(f"âŒ Error contacting MCP Server:\n{e}")

    def call_mcp_server(self, mcp_url, query, verify_ssl=False):
        payload = {"input": query}
        resp = requests.post(
            f"{mcp_url}/infer",
            json=payload,
            verify=verify_ssl,  # Set to True if using trusted SSL cert
            timeout=60
        )
        resp.raise_for_status()
        return resp.json()


if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = MCPDesktopApp()
    window.show()
    sys.exit(app.exec())


â¸»

ğŸ’¡ What This Version Does

Feature	Description
ğŸ§© MCP-only	Sends your input to your on-prem MCP server
ğŸ–¥ï¸ GUI	Same PyQt desktop window (works in EUC)
ğŸ”„ Response	Displays raw JSON/text from your MCP endpoint
âŒ Bedrock	Removed entirely (no cloud, no LLM)
ğŸ” SSL toggle	Can disable SSL verify for self-signed certs


â¸»

ğŸ§ª Example Flow
	1.	Start your EUC desktop session
	2.	Run the GUI:

python mcp_desktop_gui.py


	3.	Enter your on-prem MCP endpoint, e.g.

https://mcp-server.onprem.mycompany.com:8080


	4.	Type a query such as:

get latest metrics for pipeline A


	5.	Click ğŸš€ Send to MCP Server
	6.	Youâ€™ll see:

{
  "records": 10520,
  "errors": 12,
  "status": "healthy"
}



â¸»

ğŸ” Debugging Tips

Issue	Resolution
âŒ SSL certificate error	Set verify_ssl=False in call_mcp_server()
âŒ Connection refused	Check firewall or kube ingress
ğŸ§± EUC cannot reach on-prem	Verify EUC â†’ on-prem HTTPS access (443)
ğŸ§¾ MCP expects auth header	Add headers in requests.post() (I can show you how)


â¸»

âœ… Next Step Options

Once this GUI confirms you can talk to the MCP server successfully,
you can then extend it in one line to re-enable Bedrock integration later.

Would you like me to show you how to add authentication headers (username/token) to this MCP-only GUI next?
Thatâ€™s often needed for secure on-prem setups.