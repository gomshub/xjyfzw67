
Got it âœ… â€” you want a true native desktop app (like Claude Desktop),
not a browser-based Streamlit UI.

Letâ€™s build that version using PyQt6, which runs beautifully inside AWS End User Computing (EUC) (WorkSpaces or AppStream).

This app will:
	â€¢	Open a real window on your desktop (not in a browser).
	â€¢	Let you chat with your on-prem MCP Server.
	â€¢	Use AWS Bedrock (Claude or Titan) for LLM reasoning.
	â€¢	Display both raw MCP results and the natural-language LLM response.

â¸»

ğŸ§© Folder setup

Create a project folder:

mcp_desktop_gui/
 â”œâ”€â”€ mcp_desktop_gui.py   â† main file
 â”œâ”€â”€ requirements.txt


â¸»

ğŸ§° requirements.txt

PyQt6
boto3
requests

Install:

pip install -r requirements.txt


â¸»

ğŸªŸ mcp_desktop_gui.py

import sys
import json
import requests
import boto3
from PyQt6.QtWidgets import (
    QApplication, QWidget, QVBoxLayout, QLabel,
    QTextEdit, QPushButton, QLineEdit, QHBoxLayout, QMessageBox
)
from PyQt6.QtCore import Qt

class MCPDesktopApp(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Claude Desktop (Private MCP + Bedrock)")
        self.setMinimumSize(800, 600)
        self.layout = QVBoxLayout()

        # MCP + Bedrock Config
        self.url_label = QLabel("ğŸ”— MCP Server URL:")
        self.url_input = QLineEdit("https://mcp-server.onprem.mycompany.com:8080")

        self.model_label = QLabel("ğŸ§  Bedrock Model ID:")
        self.model_input = QLineEdit("anthropic.claude-3-sonnet-20240229-v1:0")

        url_layout = QHBoxLayout()
        url_layout.addWidget(self.url_label)
        url_layout.addWidget(self.url_input)
        self.layout.addLayout(url_layout)

        model_layout = QHBoxLayout()
        model_layout.addWidget(self.model_label)
        model_layout.addWidget(self.model_input)
        self.layout.addLayout(model_layout)

        # Chat input
        self.query_label = QLabel("ğŸ’­ Ask me anything:")
        self.query_box = QTextEdit()
        self.query_box.setPlaceholderText("Type your question here...")
        self.query_box.setFixedHeight(100)

        self.layout.addWidget(self.query_label)
        self.layout.addWidget(self.query_box)

        # Ask button
        self.ask_button = QPushButton("ğŸš€ Ask")
        self.ask_button.clicked.connect(self.handle_query)
        self.layout.addWidget(self.ask_button)

        # Output area
        self.mcp_result_label = QLabel("ğŸ“Š MCP Server Response:")
        self.mcp_result = QTextEdit()
        self.mcp_result.setReadOnly(True)

        self.llm_result_label = QLabel("ğŸ¤– Claude Response:")
        self.llm_result = QTextEdit()
        self.llm_result.setReadOnly(True)

        self.layout.addWidget(self.mcp_result_label)
        self.layout.addWidget(self.mcp_result)
        self.layout.addWidget(self.llm_result_label)
        self.layout.addWidget(self.llm_result)

        self.setLayout(self.layout)

    # --------------------------
    # Backend calls
    # --------------------------
    def handle_query(self):
        query = self.query_box.toPlainText().strip()
        if not query:
            QMessageBox.warning(self, "Input Required", "Please type a question first.")
            return

        mcp_url = self.url_input.text().strip()
        model_id = self.model_input.text().strip()

        try:
            self.mcp_result.setPlainText("Querying MCP Server...")
            mcp_data = self.call_mcp_server(mcp_url, query)
            self.mcp_result.setPlainText(json.dumps(mcp_data, indent=2))
        except Exception as e:
            self.mcp_result.setPlainText(f"âŒ Error contacting MCP Server:\n{e}")
            return

        try:
            self.llm_result.setPlainText("Calling Bedrock LLM (Claude)...")
            context = (
                f"The MCP server returned this data:\n{json.dumps(mcp_data, indent=2)}\n\n"
                f"Now answer the user query conversationally: {query}"
            )
            answer = self.call_bedrock_llm(context, model_id)
            self.llm_result.setPlainText(answer)
        except Exception as e:
            self.llm_result.setPlainText(f"âŒ Error calling Bedrock LLM:\n{e}")

    def call_mcp_server(self, mcp_url, query, verify_ssl=False):
        payload = {"input": query}
        resp = requests.post(
            f"{mcp_url}/infer",
            json=payload,
            verify=verify_ssl,
            timeout=60
        )
        resp.raise_for_status()
        return resp.json()

    def call_bedrock_llm(self, prompt, model_id, region="eu-central-1"):
        bedrock = boto3.client("bedrock-runtime", region_name=region)
        body = json.dumps({
            "prompt": f"Human: {prompt}\nAssistant:",
            "max_tokens": 400,
            "temperature": 0.7,
        })
        response = bedrock.invoke_model(
            modelId=model_id,
            body=body,
            contentType="application/json"
        )
        data = response["body"].read().decode("utf-8")
        return json.loads(data).get("completion", data)


if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = MCPDesktopApp()
    window.show()
    sys.exit(app.exec())


â¸»

ğŸš€ Run it on EUC

python mcp_desktop_gui.py

This opens a real window, just like any desktop app:

â¸»

ğŸ–¼ï¸ Interface layout

+----------------------------------------------------------+
| Claude Desktop (Private MCP + Bedrock)                   |
+----------------------------------------------------------+
| ğŸ”— MCP Server URL:  [ https://mcp-server.onprem.mycompany.com:8080 ]  |
| ğŸ§  Bedrock Model ID: [ anthropic.claude-3-sonnet-20240229-v1:0 ]     |
+----------------------------------------------------------+
| ğŸ’­ Ask me anything:                                      |
| [ Summarize todayâ€™s ingestion errors...           ]      |
|                   [ğŸš€ Ask]                               |
+----------------------------------------------------------+
| ğŸ“Š MCP Server Response:                                  |
| {                                                        |
|   "records": 10520, "errors": 12                         |
| }                                                        |
+----------------------------------------------------------+
| ğŸ¤– Claude Response:                                      |
| "The MCP server processed 10,520 records with 12 errors" |
+----------------------------------------------------------+


â¸»

ğŸ” Security & Deployment Notes

Item	Recommendation
TLS	Use real cert or disable SSL verify if self-signed
IAM	Attach Bedrock permissions to EUC instance or use AWS credentials
Firewall	Outbound HTTPS (443) from EUC â†’ MCP Server
Packaging	Optional: use pyinstaller --onefile mcp_desktop_gui.py to create a .exe or .app


â¸»

âœ… Summary

Component	Location	Purpose
MCP Server	On-prem Kube	Data provider
PyQt Desktop App	AWS EUC	Native Claude-like GUI
AWS Bedrock	AWS	LLM reasoning
Firewall	EUC â†’ On-prem HTTPS	Secure connectivity


â¸»

Would you like me to extend this PyQt GUI so it:
	1.	Keeps chat history (scrolling conversation) like Claude Desktop, and/or
	2.	Adds authentication (API key) for the on-prem MCP Server?




Perfect âœ… â€” you want to test only the MCP integration (on-prem â†’ EUC) first,
and skip connecting to AWS Bedrock until thatâ€™s working.

Thatâ€™s a smart move â€” letâ€™s simplify the GUI so it behaves exactly like Claude Desktop,
but only uses your on-prem MCP server (no AWS Bedrock calls, no cloud dependency).

â¸»

ğŸ§© Minimal MCP-only version

Just replace your mcp_desktop_gui.py content with the code below.

ğŸš€ mcp_desktop_gui.py

import sys
import json
import requests
from PyQt6.QtWidgets import (
    QApplication, QWidget, QVBoxLayout, QLabel,
    QTextEdit, QPushButton, QLineEdit, QHBoxLayout, QMessageBox
)
from PyQt6.QtCore import Qt

class MCPDesktopApp(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Claude Desktop - MCP Only")
        self.setMinimumSize(800, 600)
        self.layout = QVBoxLayout()

        # MCP Config
        self.url_label = QLabel("ğŸ”— MCP Server URL:")
        self.url_input = QLineEdit("https://mcp-server.onprem.mycompany.com:8080")

        url_layout = QHBoxLayout()
        url_layout.addWidget(self.url_label)
        url_layout.addWidget(self.url_input)
        self.layout.addLayout(url_layout)

        # Chat input
        self.query_label = QLabel("ğŸ’­ Ask me anything:")
        self.query_box = QTextEdit()
        self.query_box.setPlaceholderText("Type your question here...")
        self.query_box.setFixedHeight(100)

        self.layout.addWidget(self.query_label)
        self.layout.addWidget(self.query_box)

        # Ask button
        self.ask_button = QPushButton("ğŸš€ Send to MCP Server")
        self.ask_button.clicked.connect(self.handle_query)
        self.layout.addWidget(self.ask_button)

        # Output area
        self.mcp_result_label = QLabel("ğŸ“Š MCP Server Response:")
        self.mcp_result = QTextEdit()
        self.mcp_result.setReadOnly(True)

        self.layout.addWidget(self.mcp_result_label)
        self.layout.addWidget(self.mcp_result)

        self.setLayout(self.layout)

    # --------------------------
    # Backend call to MCP only
    # --------------------------
    def handle_query(self):
        query = self.query_box.toPlainText().strip()
        if not query:
            QMessageBox.warning(self, "Input Required", "Please type a question first.")
            return

        mcp_url = self.url_input.text().strip()

        try:
            self.mcp_result.setPlainText("â³ Sending query to MCP Server...")
            response = self.call_mcp_server(mcp_url, query)
            self.mcp_result.setPlainText(json.dumps(response, indent=2))
        except Exception as e:
            self.mcp_result.setPlainText(f"âŒ Error contacting MCP Server:\n{e}")

    def call_mcp_server(self, mcp_url, query, verify_ssl=False):
        payload = {"input": query}
        resp = requests.post(
            f"{mcp_url}/infer",
            json=payload,
            verify=verify_ssl,  # Set to True if using trusted SSL cert
            timeout=60
        )
        resp.raise_for_status()
        return resp.json()


if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = MCPDesktopApp()
    window.show()
    sys.exit(app.exec())


â¸»

ğŸ’¡ What This Version Does

Feature	Description
ğŸ§© MCP-only	Sends your input to your on-prem MCP server
ğŸ–¥ï¸ GUI	Same PyQt desktop window (works in EUC)
ğŸ”„ Response	Displays raw JSON/text from your MCP endpoint
âŒ Bedrock	Removed entirely (no cloud, no LLM)
ğŸ” SSL toggle	Can disable SSL verify for self-signed certs


â¸»

ğŸ§ª Example Flow
	1.	Start your EUC desktop session
	2.	Run the GUI:

python mcp_desktop_gui.py


	3.	Enter your on-prem MCP endpoint, e.g.

https://mcp-server.onprem.mycompany.com:8080


	4.	Type a query such as:

get latest metrics for pipeline A


	5.	Click ğŸš€ Send to MCP Server
	6.	Youâ€™ll see:

{
  "records": 10520,
  "errors": 12,
  "status": "healthy"
}



â¸»

ğŸ” Debugging Tips

Issue	Resolution
âŒ SSL certificate error	Set verify_ssl=False in call_mcp_server()
âŒ Connection refused	Check firewall or kube ingress
ğŸ§± EUC cannot reach on-prem	Verify EUC â†’ on-prem HTTPS access (443)
ğŸ§¾ MCP expects auth header	Add headers in requests.post() (I can show you how)


â¸»

âœ… Next Step Options

Once this GUI confirms you can talk to the MCP server successfully,
you can then extend it in one line to re-enable Bedrock integration later.

Would you like me to show you how to add authentication headers (username/token) to this MCP-only GUI next?
Thatâ€™s often needed for secure on-prem setups.