
Excellent and very practical question 👏 —
you’re thinking exactly like a DevOps engineer who wants to keep deployment simple inside EUC.

Let’s break this down carefully:

⸻

⚙️ Why PyQt vs Browser-based (Streamlit or FastAPI UI)

Comparison	PyQt GUI (desktop app)	Browser-based GUI (Streamlit / FastAPI + React)
Access method	Opens as a native desktop window on the EUC	Accessed via browser (e.g., http://localhost:8501)
Hosting requirement	Runs directly in EUC (no server)	Needs a lightweight web server (Streamlit/FastAPI)
Firewall complexity	Only outbound HTTPS to MCP server	Same — but open local port (e.g. 8501) in EUC
User interface style	Feels like Claude Desktop (standalone window)	Feels like a modern web app (like ChatGPT/Claude web)
Multi-user support	Single user per desktop	Easier to share among users (browser access)
Deployment in AWS EUC	Installable EXE or python mcp_desktop_gui.py	Just run streamlit run app.py and open browser
Packaging	Needs PyInstaller for EXE	No packaging needed
Look & feel	Closer to a native chat app	More flexible for quick prototyping & dashboards


⸻

💡 In Your Case (EUC + On-prem MCP + Bedrock)

You actually have both options valid — but each suits a different goal:

✅ Option 1: PyQt (Claude Desktop-style)
	•	Good if you want a true desktop experience inside EUC (no browser tab).
	•	Best for single user or test bench setup.
	•	Runs even if browser policies are strict in EUC.

✅ Option 2: Browser-based Streamlit App (recommended for simplicity)
	•	No special GUI libraries.
	•	Very quick to test and share.
	•	Easier to containerize or deploy on EUC WorkSpaces or even as a small ECS app.
	•	Uses the same code flow — just rendered as a web chat page.

⸻

🧠 So yes — you can absolutely access it from a browser.

Let me show you that equivalent browser-based version 👇
that works exactly like the MCP-only PyQt app you saw earlier — just open via browser.

⸻

🌐 Streamlit version — “Claude Desktop (Browser GUI, MCP-only)”

mcp_desktop_browser.py

import streamlit as st
import requests
import json

st.set_page_config(page_title="Claude Desktop - MCP Only", layout="wide")

st.title("💬 Claude Desktop (Browser UI - MCP Only)")

# MCP URL input
mcp_url = st.text_input("🔗 MCP Server URL", "https://mcp-server.onprem.mycompany.com:8080")

# Query input
query = st.text_area("💭 Ask me anything:", placeholder="Type your question here...")

if st.button("🚀 Send to MCP Server"):
    if not query:
        st.warning("Please enter a query first.")
    else:
        try:
            st.info("⏳ Sending query to MCP Server...")
            payload = {"input": query}
            response = requests.post(f"{mcp_url}/infer", json=payload, verify=False, timeout=60)
            response.raise_for_status()
            data = response.json()
            st.success("✅ MCP Server Response:")
            st.json(data)
        except Exception as e:
            st.error(f"❌ Error contacting MCP Server: {e}")


⸻

🚀 Run it

pip install streamlit requests
streamlit run mcp_desktop_browser.py

Then open the link printed in your EUC terminal, e.g.:

Local URL: http://localhost:8501

It opens a Claude-like chat page in your browser (inside EUC).

⸻

🖥️ What You’ll See

💬 Claude Desktop (Browser UI - MCP Only)
-------------------------------------------------
🔗 MCP Server URL: [https://mcp-server.onprem.mycompany.com:8080]
💭 Ask me anything:
[ get pipeline health metrics ]    [🚀 Send]
-------------------------------------------------
✅ MCP Server Response:
{
  "records": 10520,
  "errors": 12,
  "status": "healthy"
}


⸻

✅ Recommended approach for you

Since you’re running in AWS EUC with firewall open to on-prem,
and just need to hit the MCP API and see responses:

👉 Use the Streamlit (browser) version first
It’s easier to run, debug, and later extend with Bedrock integration.

⸻

Would you like me to extend this Streamlit (browser) version so that it:
	•	Maintains chat history (Claude-like), and
	•	Later can easily plug in Bedrock when ready?



Got it ✅ — you want a true native desktop app (like Claude Desktop),
not a browser-based Streamlit UI.

Let’s build that version using PyQt6, which runs beautifully inside AWS End User Computing (EUC) (WorkSpaces or AppStream).

This app will:
	•	Open a real window on your desktop (not in a browser).
	•	Let you chat with your on-prem MCP Server.
	•	Use AWS Bedrock (Claude or Titan) for LLM reasoning.
	•	Display both raw MCP results and the natural-language LLM response.

⸻

🧩 Folder setup

Create a project folder:

mcp_desktop_gui/
 ├── mcp_desktop_gui.py   ← main file
 ├── requirements.txt


⸻

🧰 requirements.txt

PyQt6
boto3
requests

Install:

pip install -r requirements.txt


⸻

🪟 mcp_desktop_gui.py

import sys
import json
import requests
import boto3
from PyQt6.QtWidgets import (
    QApplication, QWidget, QVBoxLayout, QLabel,
    QTextEdit, QPushButton, QLineEdit, QHBoxLayout, QMessageBox
)
from PyQt6.QtCore import Qt

class MCPDesktopApp(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Claude Desktop (Private MCP + Bedrock)")
        self.setMinimumSize(800, 600)
        self.layout = QVBoxLayout()

        # MCP + Bedrock Config
        self.url_label = QLabel("🔗 MCP Server URL:")
        self.url_input = QLineEdit("https://mcp-server.onprem.mycompany.com:8080")

        self.model_label = QLabel("🧠 Bedrock Model ID:")
        self.model_input = QLineEdit("anthropic.claude-3-sonnet-20240229-v1:0")

        url_layout = QHBoxLayout()
        url_layout.addWidget(self.url_label)
        url_layout.addWidget(self.url_input)
        self.layout.addLayout(url_layout)

        model_layout = QHBoxLayout()
        model_layout.addWidget(self.model_label)
        model_layout.addWidget(self.model_input)
        self.layout.addLayout(model_layout)

        # Chat input
        self.query_label = QLabel("💭 Ask me anything:")
        self.query_box = QTextEdit()
        self.query_box.setPlaceholderText("Type your question here...")
        self.query_box.setFixedHeight(100)

        self.layout.addWidget(self.query_label)
        self.layout.addWidget(self.query_box)

        # Ask button
        self.ask_button = QPushButton("🚀 Ask")
        self.ask_button.clicked.connect(self.handle_query)
        self.layout.addWidget(self.ask_button)

        # Output area
        self.mcp_result_label = QLabel("📊 MCP Server Response:")
        self.mcp_result = QTextEdit()
        self.mcp_result.setReadOnly(True)

        self.llm_result_label = QLabel("🤖 Claude Response:")
        self.llm_result = QTextEdit()
        self.llm_result.setReadOnly(True)

        self.layout.addWidget(self.mcp_result_label)
        self.layout.addWidget(self.mcp_result)
        self.layout.addWidget(self.llm_result_label)
        self.layout.addWidget(self.llm_result)

        self.setLayout(self.layout)

    # --------------------------
    # Backend calls
    # --------------------------
    def handle_query(self):
        query = self.query_box.toPlainText().strip()
        if not query:
            QMessageBox.warning(self, "Input Required", "Please type a question first.")
            return

        mcp_url = self.url_input.text().strip()
        model_id = self.model_input.text().strip()

        try:
            self.mcp_result.setPlainText("Querying MCP Server...")
            mcp_data = self.call_mcp_server(mcp_url, query)
            self.mcp_result.setPlainText(json.dumps(mcp_data, indent=2))
        except Exception as e:
            self.mcp_result.setPlainText(f"❌ Error contacting MCP Server:\n{e}")
            return

        try:
            self.llm_result.setPlainText("Calling Bedrock LLM (Claude)...")
            context = (
                f"The MCP server returned this data:\n{json.dumps(mcp_data, indent=2)}\n\n"
                f"Now answer the user query conversationally: {query}"
            )
            answer = self.call_bedrock_llm(context, model_id)
            self.llm_result.setPlainText(answer)
        except Exception as e:
            self.llm_result.setPlainText(f"❌ Error calling Bedrock LLM:\n{e}")

    def call_mcp_server(self, mcp_url, query, verify_ssl=False):
        payload = {"input": query}
        resp = requests.post(
            f"{mcp_url}/infer",
            json=payload,
            verify=verify_ssl,
            timeout=60
        )
        resp.raise_for_status()
        return resp.json()

    def call_bedrock_llm(self, prompt, model_id, region="eu-central-1"):
        bedrock = boto3.client("bedrock-runtime", region_name=region)
        body = json.dumps({
            "prompt": f"Human: {prompt}\nAssistant:",
            "max_tokens": 400,
            "temperature": 0.7,
        })
        response = bedrock.invoke_model(
            modelId=model_id,
            body=body,
            contentType="application/json"
        )
        data = response["body"].read().decode("utf-8")
        return json.loads(data).get("completion", data)


if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = MCPDesktopApp()
    window.show()
    sys.exit(app.exec())


⸻

🚀 Run it on EUC

python mcp_desktop_gui.py

This opens a real window, just like any desktop app:

⸻

🖼️ Interface layout

+----------------------------------------------------------+
| Claude Desktop (Private MCP + Bedrock)                   |
+----------------------------------------------------------+
| 🔗 MCP Server URL:  [ https://mcp-server.onprem.mycompany.com:8080 ]  |
| 🧠 Bedrock Model ID: [ anthropic.claude-3-sonnet-20240229-v1:0 ]     |
+----------------------------------------------------------+
| 💭 Ask me anything:                                      |
| [ Summarize today’s ingestion errors...           ]      |
|                   [🚀 Ask]                               |
+----------------------------------------------------------+
| 📊 MCP Server Response:                                  |
| {                                                        |
|   "records": 10520, "errors": 12                         |
| }                                                        |
+----------------------------------------------------------+
| 🤖 Claude Response:                                      |
| "The MCP server processed 10,520 records with 12 errors" |
+----------------------------------------------------------+


⸻

🔐 Security & Deployment Notes

Item	Recommendation
TLS	Use real cert or disable SSL verify if self-signed
IAM	Attach Bedrock permissions to EUC instance or use AWS credentials
Firewall	Outbound HTTPS (443) from EUC → MCP Server
Packaging	Optional: use pyinstaller --onefile mcp_desktop_gui.py to create a .exe or .app


⸻

✅ Summary

Component	Location	Purpose
MCP Server	On-prem Kube	Data provider
PyQt Desktop App	AWS EUC	Native Claude-like GUI
AWS Bedrock	AWS	LLM reasoning
Firewall	EUC → On-prem HTTPS	Secure connectivity


⸻

Would you like me to extend this PyQt GUI so it:
	1.	Keeps chat history (scrolling conversation) like Claude Desktop, and/or
	2.	Adds authentication (API key) for the on-prem MCP Server?




Perfect ✅ — you want to test only the MCP integration (on-prem → EUC) first,
and skip connecting to AWS Bedrock until that’s working.

That’s a smart move — let’s simplify the GUI so it behaves exactly like Claude Desktop,
but only uses your on-prem MCP server (no AWS Bedrock calls, no cloud dependency).

⸻

🧩 Minimal MCP-only version

Just replace your mcp_desktop_gui.py content with the code below.

🚀 mcp_desktop_gui.py

import sys
import json
import requests
from PyQt6.QtWidgets import (
    QApplication, QWidget, QVBoxLayout, QLabel,
    QTextEdit, QPushButton, QLineEdit, QHBoxLayout, QMessageBox
)
from PyQt6.QtCore import Qt

class MCPDesktopApp(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Claude Desktop - MCP Only")
        self.setMinimumSize(800, 600)
        self.layout = QVBoxLayout()

        # MCP Config
        self.url_label = QLabel("🔗 MCP Server URL:")
        self.url_input = QLineEdit("https://mcp-server.onprem.mycompany.com:8080")

        url_layout = QHBoxLayout()
        url_layout.addWidget(self.url_label)
        url_layout.addWidget(self.url_input)
        self.layout.addLayout(url_layout)

        # Chat input
        self.query_label = QLabel("💭 Ask me anything:")
        self.query_box = QTextEdit()
        self.query_box.setPlaceholderText("Type your question here...")
        self.query_box.setFixedHeight(100)

        self.layout.addWidget(self.query_label)
        self.layout.addWidget(self.query_box)

        # Ask button
        self.ask_button = QPushButton("🚀 Send to MCP Server")
        self.ask_button.clicked.connect(self.handle_query)
        self.layout.addWidget(self.ask_button)

        # Output area
        self.mcp_result_label = QLabel("📊 MCP Server Response:")
        self.mcp_result = QTextEdit()
        self.mcp_result.setReadOnly(True)

        self.layout.addWidget(self.mcp_result_label)
        self.layout.addWidget(self.mcp_result)

        self.setLayout(self.layout)

    # --------------------------
    # Backend call to MCP only
    # --------------------------
    def handle_query(self):
        query = self.query_box.toPlainText().strip()
        if not query:
            QMessageBox.warning(self, "Input Required", "Please type a question first.")
            return

        mcp_url = self.url_input.text().strip()

        try:
            self.mcp_result.setPlainText("⏳ Sending query to MCP Server...")
            response = self.call_mcp_server(mcp_url, query)
            self.mcp_result.setPlainText(json.dumps(response, indent=2))
        except Exception as e:
            self.mcp_result.setPlainText(f"❌ Error contacting MCP Server:\n{e}")

    def call_mcp_server(self, mcp_url, query, verify_ssl=False):
        payload = {"input": query}
        resp = requests.post(
            f"{mcp_url}/infer",
            json=payload,
            verify=verify_ssl,  # Set to True if using trusted SSL cert
            timeout=60
        )
        resp.raise_for_status()
        return resp.json()


if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = MCPDesktopApp()
    window.show()
    sys.exit(app.exec())


⸻

💡 What This Version Does

Feature	Description
🧩 MCP-only	Sends your input to your on-prem MCP server
🖥️ GUI	Same PyQt desktop window (works in EUC)
🔄 Response	Displays raw JSON/text from your MCP endpoint
❌ Bedrock	Removed entirely (no cloud, no LLM)
🔐 SSL toggle	Can disable SSL verify for self-signed certs


⸻

🧪 Example Flow
	1.	Start your EUC desktop session
	2.	Run the GUI:

python mcp_desktop_gui.py


	3.	Enter your on-prem MCP endpoint, e.g.

https://mcp-server.onprem.mycompany.com:8080


	4.	Type a query such as:

get latest metrics for pipeline A


	5.	Click 🚀 Send to MCP Server
	6.	You’ll see:

{
  "records": 10520,
  "errors": 12,
  "status": "healthy"
}



⸻

🔍 Debugging Tips

Issue	Resolution
❌ SSL certificate error	Set verify_ssl=False in call_mcp_server()
❌ Connection refused	Check firewall or kube ingress
🧱 EUC cannot reach on-prem	Verify EUC → on-prem HTTPS access (443)
🧾 MCP expects auth header	Add headers in requests.post() (I can show you how)


⸻

✅ Next Step Options

Once this GUI confirms you can talk to the MCP server successfully,
you can then extend it in one line to re-enable Bedrock integration later.

Would you like me to show you how to add authentication headers (username/token) to this MCP-only GUI next?
That’s often needed for secure on-prem setups.