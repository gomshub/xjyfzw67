Below is your final, complete, production-ready bundle in one single response:

‚úÖ ALL requests are SSL-insecure (verify=False)
‚úÖ Flask API (app.py)
‚úÖ Network diagnostics module (api.py)
‚úÖ Retries + timeouts
‚úÖ Ingress timeout configuration
‚úÖ Boto3 insecure config
‚úÖ Kubernetes Deployment + Service YAML
‚úÖ NGINX ingress with increased timeouts
‚úÖ Dockerfile

Everything is in a single comprehensive package.

‚∏ª

üü¶ 1. api.py ‚Äî INSECURE MODE (ALL REQUESTS VERIFY=FALSE)

# api.py
import socket
import ssl
import boto3
import botocore
import requests
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry

# Global retry-enabled session for HTTP(S)
def get_insecure_session():
    session = requests.Session()
    retry = Retry(
        total=5,
        backoff_factor=1.5,
        status_forcelist=[500, 502, 503, 504],
        allowed_methods=["GET", "POST", "PUT"]
    )
    adapter = HTTPAdapter(max_retries=retry)
    session.mount("http://", adapter)
    session.mount("https://", adapter)
    return session

http = get_insecure_session()

# Global insecure boto3 config
boto_config = botocore.config.Config(
    retries={'max_attempts': 8, 'mode': 'standard'},
    connect_timeout=20,
    read_timeout=120,
    tcp_keepalive=True,
    signature_version='s3v4',
    ssl_verify=False
)

def dns_test(hostname):
    try:
        ip = socket.gethostbyname(hostname)
        return {"status": "OK", "hostname": hostname, "ip": ip}
    except Exception as e:
        return {"status": "ERROR", "error": str(e)}

def tcp_test(host, port=443):
    try:
        sock = socket.create_connection((host, port), timeout=5)
        sock.close()
        return {"status": "OK", "host": host, "port": port}
    except Exception as e:
        return {"status": "ERROR", "error": str(e)}

def tls_insecure_test(url):
    try:
        r = http.get(url, verify=False, timeout=30)
        return {"status": "OK", "http_status": r.status_code, "url": url}
    except Exception as e:
        return {"status": "ERROR", "error": str(e)}

def s3_test(bucket, key):
    s3 = boto3.client("s3", config=boto_config, verify=False)
    try:
        s3.head_object(Bucket=bucket, Key=key)
        return {"status": "OK", "message": "S3 HeadObject succeeded"}
    except botocore.exceptions.EndpointConnectionError as e:
        return {"status": "NETWORK_ERROR", "error": str(e)}
    except botocore.exceptions.ClientError as e:
        return {"status": "API_ERROR", "error": str(e)}

def kms_test(kms_key_id):
    kms = boto3.client("kms", config=boto_config, verify=False)
    try:
        kms.encrypt(KeyId=kms_key_id, Plaintext=b"test-data")
        return {"status": "OK", "message": "KMS encryption succeeded"}
    except botocore.exceptions.EndpointConnectionError as e:
        return {"status": "NETWORK_ERROR", "error": str(e)}
    except botocore.exceptions.ClientError as e:
        return {"status": "API_ERROR", "error": str(e)}


‚∏ª

üü© 2. app.py ‚Äî Flask Routes

# app.py
from flask import Flask, request, jsonify
from api import dns_test, tcp_test, tls_insecure_test, s3_test, kms_test

app = Flask(__name__)

@app.route("/dns")
def test_dns():
    hostname = request.args.get("host")
    return jsonify(dns_test(hostname))

@app.route("/tcp")
def test_tcp():
    host = request.args.get("host")
    port = int(request.args.get("port", 443))
    return jsonify(tcp_test(host, port))

@app.route("/tls")
def test_tls():
    url = request.args.get("url")
    return jsonify(tls_insecure_test(url))

@app.route("/s3")
def test_s3():
    bucket = request.args.get("bucket")
    key = request.args.get("key")
    return jsonify(s3_test(bucket, key))

@app.route("/kms")
def test_kms():
    key_id = request.args.get("key")
    return jsonify(kms_test(key_id))

@app.route("/")
def home():
    return jsonify({
        "message": "Network Diagnostic API (ALL SSL INSECURE)",
        "routes": [
            "/dns?host=s3.<region>.amazonaws.com",
            "/tcp?host=10.0.1.25&port=443",
            "/tls?url=https://bucket.s3.amazonaws.com",
            "/s3?bucket=mybucket&key=file.txt",
            "/kms?key=<kms_key_id>"
        ]
    })

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=8080)


‚∏ª

üü• 3. Dockerfile (Flask + boto3 + requests)

FROM python:3.11-slim

WORKDIR /app

COPY app.py api.py /app/

RUN pip install flask boto3 botocore requests urllib3

EXPOSE 8080

CMD ["python", "app.py"]


‚∏ª

üüß 4. Kubernetes Deployment + Service

apiVersion: apps/v1
kind: Deployment
metadata:
  name: aws-network-diag
spec:
  replicas: 1
  selector:
    matchLabels:
      app: aws-diag
  template:
    metadata:
      labels:
        app: aws-diag
    spec:
      containers:
      - name: diag
        image: myrepo/aws-diag:latest
        ports:
        - containerPort: 8080
        env:
        - name: AWS_EC2_METADATA_DISABLED
          value: "true"
---
apiVersion: v1
kind: Service
metadata:
  name: aws-diag-svc
spec:
  type: ClusterIP
  selector:
    app: aws-diag
  ports:
  - port: 80
    targetPort: 8080


‚∏ª

üü¶ 5. NGINX Ingress with Increased Timeouts (to handle delay to S3/KMS)

apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: aws-diag-ingress
  annotations:
    nginx.ingress.kubernetes.io/proxy-connect-timeout: "300"
    nginx.ingress.kubernetes.io/proxy-send-timeout: "600"
    nginx.ingress.kubernetes.io/proxy-read-timeout: "600"
    nginx.ingress.kubernetes.io/proxy-body-size: "0"
    nginx.ingress.kubernetes.io/keepalive-timeout: "90"
spec:
  rules:
  - http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: aws-diag-svc
            port:
              number: 80


‚∏ª

üü® 6. How to Use

Example tests:

DNS

/dns?host=s3.eu-west-1.amazonaws.com

Raw TCP

/tcp?host=<vpce_ip>&port=443

TLS (insecure)

/tls?url=https://bucket.s3.eu-west-1.amazonaws.com

S3

/s3?bucket=my-bucket&key=test.txt

KMS

/kms?key=arn:aws:kms:region:acct:key/xxxx


‚∏ª

üü© 7. What This Solves

‚úî Slow TLS handshake to S3 PrivateLink
‚úî Slow response from KMS
‚úî Firewall SSL inspection issues
‚úî Ingress timeouts causing 504/502
‚úî NAT delays in on-prem ‚Üí AWS VPC traffic
‚úî Debugging VPC endpoint connectivity

‚∏ª

If you want next:

I can also generate:
	‚Ä¢	Helm chart
	‚Ä¢	Grafana dashboard for response time
	‚Ä¢	Script to continuously test S3/KMS latency from K8s vs local machine

Just say ‚Äúgive Helm chart‚Äù or ‚Äúgive latency dashboard‚Äù.