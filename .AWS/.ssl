Nice â€” this is very doable, and itâ€™s a clean enterprise-friendly way to fix it ğŸ‘
You can import the CA into Java cacerts during the Maven build, so every image produced is already trusted.

Below is the recommended, reproducible setup for a Spring Boot + Maven + Kubernetes build.

â¸»

âœ… Recommended approach

ğŸ‘‰ Import CA into Java cacerts during Maven build
ğŸ‘‰ Works for CI (Bamboo / GitHub Actions)
ğŸ‘‰ No runtime hacks
ğŸ‘‰ No insecure flags

â¸»

ğŸ§± Prerequisites
	â€¢	You have your CA file (example):

pictet-root-ca.pem


	â€¢	Your build runs with a JDK (not JRE)
	â€¢	You control the Docker image or Maven build

â¸»

ğŸ”¹ OPTION 1 (BEST): Import CA during Docker build (recommended)

Even if you use Maven, this is the cleanest.

Dockerfile

FROM eclipse-temurin:17-jdk

COPY certs/pictet-root-ca.pem /tmp/pictet-root-ca.pem

RUN keytool -importcert \
    -alias pictet-root \
    -file /tmp/pictet-root-ca.pem \
    -keystore $JAVA_HOME/lib/security/cacerts \
    -storepass changeit \
    -noprompt

WORKDIR /app
COPY target/app.jar app.jar
ENTRYPOINT ["java","-jar","app.jar"]

âœ… Works everywhere
âœ… Independent of Maven internals
âœ… Most production-safe

â¸»

ğŸ”¹ OPTION 2: Import CA using Maven POM (what you asked for)

Use exec-maven-plugin to run keytool during build.

â¸»

ğŸ“„ pom.xml example

<build>
  <plugins>

    <plugin>
      <groupId>org.codehaus.mojo</groupId>
      <artifactId>exec-maven-plugin</artifactId>
      <version>3.1.0</version>
      <executions>
        <execution>
          <id>import-ca</id>
          <phase>initialize</phase>
          <goals>
            <goal>exec</goal>
          </goals>
          <configuration>
            <executable>${java.home}/bin/keytool</executable>
            <arguments>
              <argument>-importcert</argument>
              <argument>-trustcacerts</argument>
              <argument>-alias</argument>
              <argument>pictet-root</argument>
              <argument>-file</argument>
              <argument>${project.basedir}/certs/pictet-root-ca.pem</argument>
              <argument>-keystore</argument>
              <argument>${java.home}/lib/security/cacerts</argument>
              <argument>-storepass</argument>
              <argument>changeit</argument>
              <argument>-noprompt</argument>
            </arguments>
          </configuration>
        </execution>
      </executions>
    </plugin>

  </plugins>
</build>


â¸»

ğŸ“ Project structure

project-root/
â”œâ”€â”€ certs/
â”‚   â””â”€â”€ pictet-root-ca.pem
â”œâ”€â”€ pom.xml
â””â”€â”€ src/


â¸»

ğŸ§ª Verify during build

Add a verification execution:

<execution>
  <id>verify-ca</id>
  <phase>verify</phase>
  <goals><goal>exec</goal></goals>
  <configuration>
    <executable>${java.home}/bin/keytool</executable>
    <arguments>
      <argument>-list</argument>
      <argument>-keystore</argument>
      <argument>${java.home}/lib/security/cacerts</argument>
      <argument>-storepass</argument>
      <argument>changeit</argument>
    </arguments>
  </configuration>
</execution>


â¸»

âš ï¸ Important warnings (read this)

âŒ Donâ€™t do this if:
	â€¢	You run Maven on shared build agents
	â€¢	You donâ€™t control the JDK installation
	â€¢	Multiple projects share the same JDK

Why?
ğŸ‘‰ This modifies the JDK truststore globally on the build agent.

â¸»

ğŸ”¥ Best practice in enterprises

Method	Recommendation
Dockerfile	â­â­â­â­â­
Maven POM	â­â­â­ (CI-controlled only)
Runtime JVM flags	â­â­
Disable SSL checks	âŒ NEVER


â¸»

ğŸ§  When Maven POM is actually OK
	â€¢	Dedicated CI agents
	â€¢	Containerized Maven build
	â€¢	JDK inside Docker build stage

â¸»

TL;DR
	â€¢	Yes, you can import CA via Maven POM
	â€¢	Use exec-maven-plugin + keytool
	â€¢	Be careful: it modifies the JDK used by Maven
	â€¢	Dockerfile import is safer

â¸»

If you want, tell me:
	â€¢	Are you building inside Docker or on bare CI agents?
	â€¢	Java version (8 / 11 / 17)?
	â€¢	Multi-stage Docker build or not?

Iâ€™ll tailor this to your exact pipeline (Bamboo / GitHub / Argo) so you donâ€™t get bitten later ğŸ”§


######

Great, now we can pin this down and make it clean + production-correct for Spring Boot on Kubernetes.

You basically have two valid fixes. Iâ€™ll start with the right Kubernetes-native one, then the TLS-required one (in case policy forces HTTPS).

â¸»

âœ… BEST FIX (Kubernetes-native, recommended)

ğŸ‘‰ Use Service DNS + HTTP for in-cluster calls

If services are on the same cluster / node, DO NOT go via Ingress.

âŒ What you have now

Spring Boot â†’ https://service.company.com â†’ Ingress â†’ Service â†’ Pod

âœ… What you SHOULD have

Spring Boot â†’ http://service-name.namespace.svc.cluster.local â†’ Pod

Example

application.yml

irp:
  admin:
    base-url: http://irp-admin:8080

(or explicitly)

irp:
  admin:
    base-url: http://irp-admin.default.svc.cluster.local:8080

Why this fixes everything
	â€¢	No TLS
	â€¢	No certs
	â€¢	No truststore
	â€¢	No ingress
	â€¢	Faster & simpler

ğŸ’¡ Kubernetes services already provide internal security + networking.

â¸»

ğŸ” If HTTPS is mandatory (policy / compliance)

Then you must fix Java truststore in the pod.

â¸»

OPTION 2ï¸âƒ£ â€” Fix Java truststore (most common enterprise setup)

Step 1: Mount internal CA into the pod

Create secret:

kubectl create secret generic internal-ca \
  --from-file=pictet-ca.pem

Deployment YAML:

volumeMounts:
  - name: internal-ca
    mountPath: /etc/ssl/certs/pictet-ca.pem
    subPath: pictet-ca.pem

volumes:
  - name: internal-ca
    secret:
      secretName: internal-ca


â¸»

Step 2: Tell Spring Boot / Java to trust it

Add JVM opts:

env:
  - name: JAVA_TOOL_OPTIONS
    value: >
      -Djavax.net.ssl.trustStore=/etc/ssl/certs/java/cacerts

(Verify path exists in your image)

â¸»

âœ… Alternative: Import CA into Java cacerts at build time

Dockerfile:

COPY pictet-ca.pem /tmp/pictet-ca.pem

RUN keytool -importcert \
  -alias pictet-root \
  -file /tmp/pictet-ca.pem \
  -keystore $JAVA_HOME/lib/security/cacerts \
  -storepass changeit \
  -noprompt

This is very stable and Helm-friendly.

â¸»

ğŸ§ª How to verify inside pod

kubectl exec -it pod-name -- bash

curl https://target-service

Then:

java -Djavax.net.debug=ssl,handshake -jar app.jar

No SunCertPathBuilderException = fixed âœ…

â¸»

ğŸ§  Decision table

Scenario	Fix
Same cluster, no policy	Service DNS + HTTP â­
Same cluster, HTTPS required	Import CA into Java
Many services	Consider Istio / Linkerd
External service	Java truststore


â¸»

TL;DR
	â€¢	Ingress should not be used for pod-to-pod calls
	â€¢	Kubernetes Service DNS is the correct solution
	â€¢	If HTTPS is forced â†’ Java truststore must include internal CA
	â€¢	This is NOT a Spring Boot bug

â¸»

If you want, paste:
	â€¢	your application.yml
	â€¢	the Service + Ingress YAML
	â€¢	base Docker image

Iâ€™ll tell you exactly what to change and what to delete (usually itâ€™s just one URL ğŸ˜‰).




=====

Ah â€” that detail is very important ğŸ‘
And it actually narrows this down a lot.

If this happens only when one service calls another service inside the SAME Kubernetes cluster, then the problem is almost certainly not â€œthe external certâ€ but how the service is being accessed.

Letâ€™s break it down cleanly.

â¸»

Whatâ€™s really happening

Your log shows the call going to:

https://irp-admin-ctlq.pictet.com/irp-admin/v1/...

So even though:
	â€¢	caller pod âœ”ï¸
	â€¢	target pod âœ”ï¸
	â€¢	same cluster âœ”ï¸

ğŸ‘‰ The call is NOT using Kubernetes service DNS
ğŸ‘‰ It is going out of the cluster and back in (Ingress / LB / gateway)

That explains why SSL is involved at all.

â¸»

Why this fails only after Robica v2

ğŸ”´ Scenario 1 (most common)

Ingress certificate changed or is now:
	â€¢	issued by internal CA
	â€¢	missing intermediate cert
	â€¢	different chain than before

Robica v1 trusted it
Robica v2 does not

Even though traffic is â€œinternalâ€, TLS happens at:

Pod â†’ Ingress â†’ Service

Java still validates the cert.

â¸»

ğŸ”´ Scenario 2

Robica v2:
	â€¢	switched to a different base image
	â€¢	lost corporate CA bundle
	â€¢	lost /etc/ssl/certs propagation into Java

So internal ingress cert is no longer trusted.

â¸»

ğŸ”´ Scenario 3 (Kubernetes-native issue)

Service should be called like this:

http://irp-admin.ctlq.svc.cluster.local

But instead itâ€™s called via:

https://irp-admin-ctlq.pictet.com

That forces:
	â€¢	TLS
	â€¢	cert validation
	â€¢	ingress hop

â¸»

ğŸ” Quick proof (do this test)

From the calling pod:

Test 1 â€“ call via service DNS

curl http://irp-admin:8080/irp-admin/v1/axioma-proxy/find-all-security-proxies

If âœ… works â†’ app + networking are fine

â¸»

Test 2 â€“ call via ingress hostname

curl https://irp-admin-ctlq.pictet.com/irp-admin/v1/...

If âŒ fails â†’ cert trust problem confirmed

â¸»

âœ… Correct architectural fix (BEST)

ğŸ”¥ Use Kubernetes service DNS for intra-cluster calls

No TLS. No ingress. No cert drama.

IRP_ADMIN_BASE_URL=http://irp-admin:8080

Benefits:
	â€¢	faster
	â€¢	safer
	â€¢	zero SSL config
	â€¢	no dependency on ingress

This is the recommended K8s pattern.

â¸»

âœ… If HTTPS is mandatory (policy reason)

Then you must do one of these:

Option A: Trust ingress cert
	â€¢	Import ingress CA into Java truststore of Robica v2

Option B: mTLS / service mesh
	â€¢	Istio / Linkerd handles certs automatically
	â€¢	App never sees TLS

â¸»

âŒ Anti-pattern (what you currently have)

Pod â†’ Internet DNS â†’ Load Balancer â†’ Ingress â†’ Pod

Even though all pods are â€œinsideâ€.

â¸»

Why it suddenly surfaced now

Robica v2 likely:
	â€¢	upgraded Java
	â€¢	changed base image
	â€¢	removed internal CA bundle
	â€¢	or tightened SSL validation

So the design flaw was always there â€” v2 just exposed it.

â¸»

TL;DR
	â€¢	Same cluster â‰  no SSL
	â€¢	Youâ€™re calling Ingress instead of Service
	â€¢	Java doesnâ€™t trust ingress cert anymore
	â€¢	Fix by using service DNS or importing CA

If you want, paste:
	â€¢	your Service YAML
	â€¢	your Ingress YAML
	â€¢	how the URL is configured (env / config)

Iâ€™ll tell you exactly which line to change to kill this issue for good ğŸ‘Œ