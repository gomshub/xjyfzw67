Ah â€” that detail is very important ğŸ‘
And it actually narrows this down a lot.

If this happens only when one service calls another service inside the SAME Kubernetes cluster, then the problem is almost certainly not â€œthe external certâ€ but how the service is being accessed.

Letâ€™s break it down cleanly.

â¸»

Whatâ€™s really happening

Your log shows the call going to:

https://irp-admin-ctlq.pictet.com/irp-admin/v1/...

So even though:
	â€¢	caller pod âœ”ï¸
	â€¢	target pod âœ”ï¸
	â€¢	same cluster âœ”ï¸

ğŸ‘‰ The call is NOT using Kubernetes service DNS
ğŸ‘‰ It is going out of the cluster and back in (Ingress / LB / gateway)

That explains why SSL is involved at all.

â¸»

Why this fails only after Robica v2

ğŸ”´ Scenario 1 (most common)

Ingress certificate changed or is now:
	â€¢	issued by internal CA
	â€¢	missing intermediate cert
	â€¢	different chain than before

Robica v1 trusted it
Robica v2 does not

Even though traffic is â€œinternalâ€, TLS happens at:

Pod â†’ Ingress â†’ Service

Java still validates the cert.

â¸»

ğŸ”´ Scenario 2

Robica v2:
	â€¢	switched to a different base image
	â€¢	lost corporate CA bundle
	â€¢	lost /etc/ssl/certs propagation into Java

So internal ingress cert is no longer trusted.

â¸»

ğŸ”´ Scenario 3 (Kubernetes-native issue)

Service should be called like this:

http://irp-admin.ctlq.svc.cluster.local

But instead itâ€™s called via:

https://irp-admin-ctlq.pictet.com

That forces:
	â€¢	TLS
	â€¢	cert validation
	â€¢	ingress hop

â¸»

ğŸ” Quick proof (do this test)

From the calling pod:

Test 1 â€“ call via service DNS

curl http://irp-admin:8080/irp-admin/v1/axioma-proxy/find-all-security-proxies

If âœ… works â†’ app + networking are fine

â¸»

Test 2 â€“ call via ingress hostname

curl https://irp-admin-ctlq.pictet.com/irp-admin/v1/...

If âŒ fails â†’ cert trust problem confirmed

â¸»

âœ… Correct architectural fix (BEST)

ğŸ”¥ Use Kubernetes service DNS for intra-cluster calls

No TLS. No ingress. No cert drama.

IRP_ADMIN_BASE_URL=http://irp-admin:8080

Benefits:
	â€¢	faster
	â€¢	safer
	â€¢	zero SSL config
	â€¢	no dependency on ingress

This is the recommended K8s pattern.

â¸»

âœ… If HTTPS is mandatory (policy reason)

Then you must do one of these:

Option A: Trust ingress cert
	â€¢	Import ingress CA into Java truststore of Robica v2

Option B: mTLS / service mesh
	â€¢	Istio / Linkerd handles certs automatically
	â€¢	App never sees TLS

â¸»

âŒ Anti-pattern (what you currently have)

Pod â†’ Internet DNS â†’ Load Balancer â†’ Ingress â†’ Pod

Even though all pods are â€œinsideâ€.

â¸»

Why it suddenly surfaced now

Robica v2 likely:
	â€¢	upgraded Java
	â€¢	changed base image
	â€¢	removed internal CA bundle
	â€¢	or tightened SSL validation

So the design flaw was always there â€” v2 just exposed it.

â¸»

TL;DR
	â€¢	Same cluster â‰  no SSL
	â€¢	Youâ€™re calling Ingress instead of Service
	â€¢	Java doesnâ€™t trust ingress cert anymore
	â€¢	Fix by using service DNS or importing CA

If you want, paste:
	â€¢	your Service YAML
	â€¢	your Ingress YAML
	â€¢	how the URL is configured (env / config)

Iâ€™ll tell you exactly which line to change to kill this issue for good ğŸ‘Œ