Hereâ€™s the **cleanest, neatest single response** that explains the **bootstrap image trick**, plus the **Terraform code** and **GitHub Actions workflow** you need â€” all in one tight package.

---

# ðŸŒŸ **Bootstrap Image Pattern (Clean + Simple)**

To avoid the chickenâ€‘orâ€‘egg problem (ECR needs Terraform, image needs ECR), you run the **first Terraform apply** using a **placeholder image tag**:

```hcl
image_tag = "bootstrap"
```

This lets Terraform create the ECR repo and Lambda/ECS resources even though the real image doesnâ€™t exist yet.  
Then GitHub Actions builds the real image, pushes it to ECR, and runs Terraform again with the updated tag.

---

# ðŸŸ¦ **Terraform Code (Minimal + Works Everywhere)**

```hcl
variable "image_tag" {
  type    = string
  default = "bootstrap"   # placeholder for first apply
}

resource "aws_ecr_repository" "lambda_repo" {
  name = "my-lambda-repo"
}

resource "aws_iam_role" "lambda_exec" {
  name = "lambda-exec-role"

  assume_role_policy = jsonencode({
    Version = "2012-10-17"
    Statement = [{
      Effect = "Allow"
      Principal = { Service = "lambda.amazonaws.com" }
      Action = "sts:AssumeRole"
    }]
  })
}

resource "aws_lambda_function" "my_lambda" {
  function_name = "my-lambda"
  package_type  = "Image"

  image_uri = "${aws_ecr_repository.lambda_repo.repository_url}:${var.image_tag}"

  role = aws_iam_role.lambda_exec.arn
}
```

### **Bootstrap step (run once):**
```
terraform apply
```

This creates ECR + Lambda using the placeholder image.

---

# ðŸŸ© **GitHub Actions Workflow (Build â†’ Push â†’ Terraform Apply)**

```yaml
name: Deploy Lambda

on:
  push:
    branches: [ "main" ]

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: eu-west-1

      - name: Login to ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build Docker image
        run: |
          IMAGE_TAG=$(date +%s)
          echo "IMAGE_TAG=$IMAGE_TAG" >> $GITHUB_ENV
          docker build -t lambda:${IMAGE_TAG} .

      - name: Push to ECR
        run: |
          REPO="${{ steps.login-ecr.outputs.registry }}/my-lambda-repo"
          docker tag lambda:${IMAGE_TAG} $REPO:${IMAGE_TAG}
          docker push $REPO:${IMAGE_TAG}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3

      - name: Terraform Init
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}   # for private module registry
        run: terraform init

      - name: Terraform Apply with new image tag
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: terraform apply -auto-approve -var="image_tag=${IMAGE_TAG}"
```

---

# ðŸŽ¯ **Final Summary (Oneâ€‘liner)**  
**Bootstrap once with `image_tag = "bootstrap"` â†’ CI builds real image â†’ CI pushes to ECR â†’ CI runs `terraform apply -var="image_tag=<real tag>"` â†’ Lambda/ECS updates cleanly.**

If you want, I can also give you a **diagram** of this flow or a **Kaniko version** of the workflow.
